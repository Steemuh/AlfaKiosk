{"version":3,"sources":["../../../../../../node_modules/.pnpm/cookie%401.0.2/node_modules/cookie/src/index.ts","../../../../../../node_modules/.pnpm/%40saleor%2Bauth-sdk%401.0.3_next%4016.0.10_%40babel%2Bcore%407.24.9_react-dom%4019.1.2_react%4019.1.2__react%401_pfagujp4hhbpzdb66xirwflqg4/node_modules/%40saleor/auth-sdk/chunk-263DHBMK.mjs","../../../../../../node_modules/.pnpm/tslib%402.8.1/node_modules/tslib/tslib.es6.mjs","../../../../../../node_modules/.pnpm/%40saleor%2Bauth-sdk%401.0.3_next%4016.0.10_%40babel%2Bcore%407.24.9_react-dom%4019.1.2_react%4019.1.2__react%401_pfagujp4hhbpzdb66xirwflqg4/node_modules/%40saleor/auth-sdk/chunk-BZFBMGPG.mjs","../../../../../../node_modules/.pnpm/%40saleor%2Bauth-sdk%401.0.3_next%4016.0.10_%40babel%2Bcore%407.24.9_react-dom%4019.1.2_react%4019.1.2__react%401_pfagujp4hhbpzdb66xirwflqg4/node_modules/%40saleor/auth-sdk/chunk-IRFIDVVY.mjs","../../../../../../node_modules/.pnpm/%40saleor%2Bauth-sdk%401.0.3_next%4016.0.10_%40babel%2Bcore%407.24.9_react-dom%4019.1.2_react%4019.1.2__react%401_pfagujp4hhbpzdb66xirwflqg4/node_modules/%40saleor/auth-sdk/chunk-K5MTKW5C.mjs","../../../../../../node_modules/.pnpm/%40saleor%2Bauth-sdk%401.0.3_next%4016.0.10_%40babel%2Bcore%407.24.9_react-dom%4019.1.2_react%4019.1.2__react%401_pfagujp4hhbpzdb66xirwflqg4/node_modules/%40saleor/auth-sdk/chunk-NAQNA6DI.mjs","../../../../../../packages/shared/src/ui/components/AuthProvider.tsx","../../../../../../node_modules/.pnpm/%400no-co%2Bgraphql.web%401.0.7_graphql%4016.8.1/node_modules/%400no-co/graphql.web/src/kind.js","../../../../../../node_modules/.pnpm/ts-invariant%400.10.3/node_modules/ts-invariant/src/invariant.ts","../../../../../../node_modules/.pnpm/%40saleor%2Bauth-sdk%401.0.3_next%4016.0.10_%40babel%2Bcore%407.24.9_react-dom%4019.1.2_react%4019.1.2__react%401_pfagujp4hhbpzdb66xirwflqg4/node_modules/%40saleor/auth-sdk/chunk-7JTFMRQS.mjs","../../../../../../node_modules/.pnpm/%40urql%2Bcore%404.3.0_graphql%4016.8.1/node_modules/%40urql/core/src/utils/error.ts","../../../../../../node_modules/.pnpm/%40saleor%2Bauth-sdk%401.0.3_next%4016.0.10_%40babel%2Bcore%407.24.9_react-dom%4019.1.2_react%4019.1.2__react%401_pfagujp4hhbpzdb66xirwflqg4/node_modules/%40saleor/auth-sdk/chunk-74GMXOK4.mjs","../../../../../../node_modules/.pnpm/%40saleor%2Bauth-sdk%401.0.3_next%4016.0.10_%40babel%2Bcore%407.24.9_react-dom%4019.1.2_react%4019.1.2__react%401_pfagujp4hhbpzdb66xirwflqg4/node_modules/%40saleor/auth-sdk/chunk-WJVMUY3P.mjs","../../../../../../node_modules/.pnpm/%40urql%2Bcore%404.3.0_graphql%4016.8.1/node_modules/%40urql/core/src/utils/collectTypenames.ts","../../../../../../node_modules/.pnpm/urql%404.0.6_graphql%4016.8.1_react%4019.1.2/node_modules/urql/src/context.ts","../../../../../../node_modules/.pnpm/%40saleor%2Bauth-sdk%401.0.3_next%4016.0.10_%40babel%2Bcore%407.24.9_react-dom%4019.1.2_react%4019.1.2__react%401_pfagujp4hhbpzdb66xirwflqg4/node_modules/%40saleor/auth-sdk/chunk-7JBN5R2C.mjs","../../../../../../node_modules/.pnpm/%40urql%2Bcore%404.3.0_graphql%4016.8.1/node_modules/%40urql/core/src/utils/formatDocument.ts","../../../../../../node_modules/.pnpm/urql%404.0.6_graphql%4016.8.1_react%4019.1.2/node_modules/urql/src/hooks/state.ts","../../../../../../node_modules/.pnpm/%400no-co%2Bgraphql.web%401.0.7_graphql%4016.8.1/node_modules/%400no-co/graphql.web/src/error.ts","../../../../../../node_modules/.pnpm/%40urql%2Bcore%404.3.0_graphql%4016.8.1/node_modules/%40urql/core/src/utils/hash.ts","../../../../../../node_modules/.pnpm/%40urql%2Bcore%404.3.0_graphql%4016.8.1/node_modules/%40urql/core/src/utils/variables.ts","../../../../../../node_modules/.pnpm/%400no-co%2Bgraphql.web%401.0.7_graphql%4016.8.1/node_modules/%400no-co/graphql.web/src/parser.ts","../../../../../../node_modules/.pnpm/urql%404.0.6_graphql%4016.8.1_react%4019.1.2/node_modules/urql/src/hooks/useMutation.ts","../../../../../../node_modules/.pnpm/%40urql%2Bcore%404.3.0_graphql%4016.8.1/node_modules/%40urql/core/src/utils/maskTypename.ts","../../../../../../node_modules/.pnpm/urql%404.0.6_graphql%4016.8.1_react%4019.1.2/node_modules/urql/src/hooks/useRequest.ts","../../../../../../node_modules/.pnpm/%40urql%2Bcore%404.3.0_graphql%4016.8.1/node_modules/%40urql/core/src/utils/streamUtils.ts","../../../../../../node_modules/.pnpm/%40urql%2Bcore%404.3.0_graphql%4016.8.1/node_modules/%40urql/core/src/utils/request.ts","../../../../../../node_modules/.pnpm/urql%404.0.6_graphql%4016.8.1_react%4019.1.2/node_modules/urql/src/hooks/cache.ts","../../../../../../node_modules/.pnpm/%40urql%2Bcore%404.3.0_graphql%4016.8.1/node_modules/%40urql/core/src/utils/operation.ts","../../../../../../node_modules/.pnpm/%40urql%2Bcore%404.3.0_graphql%4016.8.1/node_modules/%40urql/core/src/utils/index.ts","../../../../../../node_modules/.pnpm/urql%404.0.6_graphql%4016.8.1_react%4019.1.2/node_modules/urql/src/hooks/useQuery.ts","../../../../../../node_modules/.pnpm/%40urql%2Bcore%404.3.0_graphql%4016.8.1/node_modules/%40urql/core/src/gql.ts","../../../../../../node_modules/.pnpm/%40urql%2Bcore%404.3.0_graphql%4016.8.1/node_modules/%40urql/core/src/exchanges/cache.ts","../../../../../../node_modules/.pnpm/%40urql%2Bcore%404.3.0_graphql%4016.8.1/node_modules/%40urql/core/src/utils/result.ts","../../../../../../node_modules/.pnpm/urql%404.0.6_graphql%4016.8.1_react%4019.1.2/node_modules/urql/src/hooks/useSubscription.ts","../../../../../../node_modules/.pnpm/%40urql%2Bcore%404.3.0_graphql%4016.8.1/node_modules/%40urql/core/src/exchanges/ssr.ts","../../../../../../node_modules/.pnpm/urql%404.0.6_graphql%4016.8.1_react%4019.1.2/node_modules/urql/src/components/Mutation.ts","../../../../../../node_modules/.pnpm/urql%404.0.6_graphql%4016.8.1_react%4019.1.2/node_modules/urql/src/components/Query.ts","../../../../../../node_modules/.pnpm/urql%404.0.6_graphql%4016.8.1_react%4019.1.2/node_modules/urql/src/components/Subscription.ts","../../../../../../node_modules/.pnpm/%40urql%2Bcore%404.3.0_graphql%4016.8.1/node_modules/%40urql/core/src/internal/fetchOptions.ts","../../../../../../node_modules/.pnpm/%40urql%2Bcore%404.3.0_graphql%4016.8.1/node_modules/%40urql/core/src/exchanges/subscription.ts","../../../../../../node_modules/.pnpm/%40urql%2Bcore%404.3.0_graphql%4016.8.1/node_modules/%40urql/core/src/internal/fetchSource.ts","../../../../../../node_modules/.pnpm/%40urql%2Bcore%404.3.0_graphql%4016.8.1/node_modules/%40urql/core/src/exchanges/debug.ts","../../../../../../node_modules/.pnpm/%40urql%2Bcore%404.3.0_graphql%4016.8.1/node_modules/%40urql/core/src/exchanges/dedup.ts","../../../../../../node_modules/.pnpm/%40urql%2Bcore%404.3.0_graphql%4016.8.1/node_modules/%40urql/core/src/exchanges/fetch.ts","../../../../../../node_modules/.pnpm/%40urql%2Bcore%404.3.0_graphql%4016.8.1/node_modules/%40urql/core/src/exchanges/compose.ts","../../../../../../node_modules/.pnpm/%40urql%2Bcore%404.3.0_graphql%4016.8.1/node_modules/%40urql/core/src/exchanges/map.ts","../../../../../../node_modules/.pnpm/%40urql%2Bcore%404.3.0_graphql%4016.8.1/node_modules/%40urql/core/src/exchanges/fallback.ts","../../../../../../node_modules/.pnpm/%40urql%2Bcore%404.3.0_graphql%4016.8.1/node_modules/%40urql/core/src/client.ts","../../../../../../node_modules/.pnpm/%400no-co%2Bgraphql.web%401.0.7_graphql%4016.8.1/node_modules/%400no-co/graphql.web/src/visitor.ts","../../../../../../node_modules/.pnpm/%400no-co%2Bgraphql.web%401.0.7_graphql%4016.8.1/node_modules/%400no-co/graphql.web/src/printer.ts","../../../../../../node_modules/.pnpm/%400no-co%2Bgraphql.web%401.0.7_graphql%4016.8.1/node_modules/%400no-co/graphql.web/src/values.ts"],"sourcesContent":["/**\n * RegExp to match cookie-name in RFC 6265 sec 4.1.1\n * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2\n * which has been replaced by the token definition in RFC 7230 appendix B.\n *\n * cookie-name       = token\n * token             = 1*tchar\n * tchar             = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" /\n *                     \"*\" / \"+\" / \"-\" / \".\" / \"^\" / \"_\" /\n *                     \"`\" / \"|\" / \"~\" / DIGIT / ALPHA\n *\n * Note: Allowing more characters - https://github.com/jshttp/cookie/issues/191\n * Allow same range as cookie value, except `=`, which delimits end of name.\n */\nconst cookieNameRegExp = /^[\\u0021-\\u003A\\u003C\\u003E-\\u007E]+$/;\n\n/**\n * RegExp to match cookie-value in RFC 6265 sec 4.1.1\n *\n * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )\n * cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E\n *                     ; US-ASCII characters excluding CTLs,\n *                     ; whitespace DQUOTE, comma, semicolon,\n *                     ; and backslash\n *\n * Allowing more characters: https://github.com/jshttp/cookie/issues/191\n * Comma, backslash, and DQUOTE are not part of the parsing algorithm.\n */\nconst cookieValueRegExp = /^[\\u0021-\\u003A\\u003C-\\u007E]*$/;\n\n/**\n * RegExp to match domain-value in RFC 6265 sec 4.1.1\n *\n * domain-value      = <subdomain>\n *                     ; defined in [RFC1034], Section 3.5, as\n *                     ; enhanced by [RFC1123], Section 2.1\n * <subdomain>       = <label> | <subdomain> \".\" <label>\n * <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]\n *                     Labels must be 63 characters or less.\n *                     'let-dig' not 'letter' in the first char, per RFC1123\n * <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>\n * <let-dig-hyp>     = <let-dig> | \"-\"\n * <let-dig>         = <letter> | <digit>\n * <letter>          = any one of the 52 alphabetic characters A through Z in\n *                     upper case and a through z in lower case\n * <digit>           = any one of the ten digits 0 through 9\n *\n * Keep support for leading dot: https://github.com/jshttp/cookie/issues/173\n *\n * > (Note that a leading %x2E (\".\"), if present, is ignored even though that\n * character is not permitted, but a trailing %x2E (\".\"), if present, will\n * cause the user agent to ignore the attribute.)\n */\nconst domainValueRegExp =\n  /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;\n\n/**\n * RegExp to match path-value in RFC 6265 sec 4.1.1\n *\n * path-value        = <any CHAR except CTLs or \";\">\n * CHAR              = %x01-7F\n *                     ; defined in RFC 5234 appendix B.1\n */\nconst pathValueRegExp = /^[\\u0020-\\u003A\\u003D-\\u007E]*$/;\n\nconst __toString = Object.prototype.toString;\n\nconst NullObject = /* @__PURE__ */ (() => {\n  const C = function () {};\n  C.prototype = Object.create(null);\n  return C;\n})() as unknown as { new (): any };\n\n/**\n * Parse options.\n */\nexport interface ParseOptions {\n  /**\n   * Specifies a function that will be used to decode a [cookie-value](https://datatracker.ietf.org/doc/html/rfc6265#section-4.1.1).\n   * Since the value of a cookie has a limited character set (and must be a simple string), this function can be used to decode\n   * a previously-encoded cookie value into a JavaScript string.\n   *\n   * The default function is the global `decodeURIComponent`, wrapped in a `try..catch`. If an error\n   * is thrown it will return the cookie's original value. If you provide your own encode/decode\n   * scheme you must ensure errors are appropriately handled.\n   *\n   * @default decode\n   */\n  decode?: (str: string) => string | undefined;\n}\n\n/**\n * Parse a cookie header.\n *\n * Parse the given cookie header string into an object\n * The object has the various cookies as keys(names) => values\n */\nexport function parse(\n  str: string,\n  options?: ParseOptions,\n): Record<string, string | undefined> {\n  const obj: Record<string, string | undefined> = new NullObject();\n  const len = str.length;\n  // RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.\n  if (len < 2) return obj;\n\n  const dec = options?.decode || decode;\n  let index = 0;\n\n  do {\n    const eqIdx = str.indexOf(\"=\", index);\n    if (eqIdx === -1) break; // No more cookie pairs.\n\n    const colonIdx = str.indexOf(\";\", index);\n    const endIdx = colonIdx === -1 ? len : colonIdx;\n\n    if (eqIdx > endIdx) {\n      // backtrack on prior semicolon\n      index = str.lastIndexOf(\";\", eqIdx - 1) + 1;\n      continue;\n    }\n\n    const keyStartIdx = startIndex(str, index, eqIdx);\n    const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);\n    const key = str.slice(keyStartIdx, keyEndIdx);\n\n    // only assign once\n    if (obj[key] === undefined) {\n      let valStartIdx = startIndex(str, eqIdx + 1, endIdx);\n      let valEndIdx = endIndex(str, endIdx, valStartIdx);\n\n      const value = dec(str.slice(valStartIdx, valEndIdx));\n      obj[key] = value;\n    }\n\n    index = endIdx + 1;\n  } while (index < len);\n\n  return obj;\n}\n\nfunction startIndex(str: string, index: number, max: number) {\n  do {\n    const code = str.charCodeAt(index);\n    if (code !== 0x20 /*   */ && code !== 0x09 /* \\t */) return index;\n  } while (++index < max);\n  return max;\n}\n\nfunction endIndex(str: string, index: number, min: number) {\n  while (index > min) {\n    const code = str.charCodeAt(--index);\n    if (code !== 0x20 /*   */ && code !== 0x09 /* \\t */) return index + 1;\n  }\n  return min;\n}\n\n/**\n * Serialize options.\n */\nexport interface SerializeOptions {\n  /**\n   * Specifies a function that will be used to encode a [cookie-value](https://datatracker.ietf.org/doc/html/rfc6265#section-4.1.1).\n   * Since value of a cookie has a limited character set (and must be a simple string), this function can be used to encode\n   * a value into a string suited for a cookie's value, and should mirror `decode` when parsing.\n   *\n   * @default encodeURIComponent\n   */\n  encode?: (str: string) => string;\n  /**\n   * Specifies the `number` (in seconds) to be the value for the [`Max-Age` `Set-Cookie` attribute](https://tools.ietf.org/html/rfc6265#section-5.2.2).\n   *\n   * The [cookie storage model specification](https://tools.ietf.org/html/rfc6265#section-5.3) states that if both `expires` and\n   * `maxAge` are set, then `maxAge` takes precedence, but it is possible not all clients by obey this,\n   * so if both are set, they should point to the same date and time.\n   */\n  maxAge?: number;\n  /**\n   * Specifies the `Date` object to be the value for the [`Expires` `Set-Cookie` attribute](https://tools.ietf.org/html/rfc6265#section-5.2.1).\n   * When no expiration is set clients consider this a \"non-persistent cookie\" and delete it the current session is over.\n   *\n   * The [cookie storage model specification](https://tools.ietf.org/html/rfc6265#section-5.3) states that if both `expires` and\n   * `maxAge` are set, then `maxAge` takes precedence, but it is possible not all clients by obey this,\n   * so if both are set, they should point to the same date and time.\n   */\n  expires?: Date;\n  /**\n   * Specifies the value for the [`Domain` `Set-Cookie` attribute](https://tools.ietf.org/html/rfc6265#section-5.2.3).\n   * When no domain is set clients consider the cookie to apply to the current domain only.\n   */\n  domain?: string;\n  /**\n   * Specifies the value for the [`Path` `Set-Cookie` attribute](https://tools.ietf.org/html/rfc6265#section-5.2.4).\n   * When no path is set, the path is considered the [\"default path\"](https://tools.ietf.org/html/rfc6265#section-5.1.4).\n   */\n  path?: string;\n  /**\n   * Enables the [`HttpOnly` `Set-Cookie` attribute](https://tools.ietf.org/html/rfc6265#section-5.2.6).\n   * When enabled, clients will not allow client-side JavaScript to see the cookie in `document.cookie`.\n   */\n  httpOnly?: boolean;\n  /**\n   * Enables the [`Secure` `Set-Cookie` attribute](https://tools.ietf.org/html/rfc6265#section-5.2.5).\n   * When enabled, clients will only send the cookie back if the browser has a HTTPS connection.\n   */\n  secure?: boolean;\n  /**\n   * Enables the [`Partitioned` `Set-Cookie` attribute](https://tools.ietf.org/html/draft-cutler-httpbis-partitioned-cookies/).\n   * When enabled, clients will only send the cookie back when the current domain _and_ top-level domain matches.\n   *\n   * This is an attribute that has not yet been fully standardized, and may change in the future.\n   * This also means clients may ignore this attribute until they understand it. More information\n   * about can be found in [the proposal](https://github.com/privacycg/CHIPS).\n   */\n  partitioned?: boolean;\n  /**\n   * Specifies the value for the [`Priority` `Set-Cookie` attribute](https://tools.ietf.org/html/draft-west-cookie-priority-00#section-4.1).\n   *\n   * - `'low'` will set the `Priority` attribute to `Low`.\n   * - `'medium'` will set the `Priority` attribute to `Medium`, the default priority when not set.\n   * - `'high'` will set the `Priority` attribute to `High`.\n   *\n   * More information about priority levels can be found in [the specification](https://tools.ietf.org/html/draft-west-cookie-priority-00#section-4.1).\n   */\n  priority?: \"low\" | \"medium\" | \"high\";\n  /**\n   * Specifies the value for the [`SameSite` `Set-Cookie` attribute](https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-09#section-5.4.7).\n   *\n   * - `true` will set the `SameSite` attribute to `Strict` for strict same site enforcement.\n   * - `'lax'` will set the `SameSite` attribute to `Lax` for lax same site enforcement.\n   * - `'none'` will set the `SameSite` attribute to `None` for an explicit cross-site cookie.\n   * - `'strict'` will set the `SameSite` attribute to `Strict` for strict same site enforcement.\n   *\n   * More information about enforcement levels can be found in [the specification](https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-09#section-5.4.7).\n   */\n  sameSite?: boolean | \"lax\" | \"strict\" | \"none\";\n}\n\n/**\n * Serialize data into a cookie header.\n *\n * Serialize a name value pair into a cookie string suitable for\n * http headers. An optional options object specifies cookie parameters.\n *\n * serialize('foo', 'bar', { httpOnly: true })\n *   => \"foo=bar; httpOnly\"\n */\nexport function serialize(\n  name: string,\n  val: string,\n  options?: SerializeOptions,\n): string {\n  const enc = options?.encode || encodeURIComponent;\n\n  if (!cookieNameRegExp.test(name)) {\n    throw new TypeError(`argument name is invalid: ${name}`);\n  }\n\n  const value = enc(val);\n\n  if (!cookieValueRegExp.test(value)) {\n    throw new TypeError(`argument val is invalid: ${val}`);\n  }\n\n  let str = name + \"=\" + value;\n  if (!options) return str;\n\n  if (options.maxAge !== undefined) {\n    if (!Number.isInteger(options.maxAge)) {\n      throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);\n    }\n\n    str += \"; Max-Age=\" + options.maxAge;\n  }\n\n  if (options.domain) {\n    if (!domainValueRegExp.test(options.domain)) {\n      throw new TypeError(`option domain is invalid: ${options.domain}`);\n    }\n\n    str += \"; Domain=\" + options.domain;\n  }\n\n  if (options.path) {\n    if (!pathValueRegExp.test(options.path)) {\n      throw new TypeError(`option path is invalid: ${options.path}`);\n    }\n\n    str += \"; Path=\" + options.path;\n  }\n\n  if (options.expires) {\n    if (\n      !isDate(options.expires) ||\n      !Number.isFinite(options.expires.valueOf())\n    ) {\n      throw new TypeError(`option expires is invalid: ${options.expires}`);\n    }\n\n    str += \"; Expires=\" + options.expires.toUTCString();\n  }\n\n  if (options.httpOnly) {\n    str += \"; HttpOnly\";\n  }\n\n  if (options.secure) {\n    str += \"; Secure\";\n  }\n\n  if (options.partitioned) {\n    str += \"; Partitioned\";\n  }\n\n  if (options.priority) {\n    const priority =\n      typeof options.priority === \"string\"\n        ? options.priority.toLowerCase()\n        : undefined;\n    switch (priority) {\n      case \"low\":\n        str += \"; Priority=Low\";\n        break;\n      case \"medium\":\n        str += \"; Priority=Medium\";\n        break;\n      case \"high\":\n        str += \"; Priority=High\";\n        break;\n      default:\n        throw new TypeError(`option priority is invalid: ${options.priority}`);\n    }\n  }\n\n  if (options.sameSite) {\n    const sameSite =\n      typeof options.sameSite === \"string\"\n        ? options.sameSite.toLowerCase()\n        : options.sameSite;\n    switch (sameSite) {\n      case true:\n      case \"strict\":\n        str += \"; SameSite=Strict\";\n        break;\n      case \"lax\":\n        str += \"; SameSite=Lax\";\n        break;\n      case \"none\":\n        str += \"; SameSite=None\";\n        break;\n      default:\n        throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);\n    }\n  }\n\n  return str;\n}\n\n/**\n * URL-decode string value. Optimized to skip native call when no %.\n */\nfunction decode(str: string): string {\n  if (str.indexOf(\"%\") === -1) return str;\n\n  try {\n    return decodeURIComponent(str);\n  } catch (e) {\n    return str;\n  }\n}\n\n/**\n * Determine if value is a Date.\n */\nfunction isDate(val: any): val is Date {\n  return __toString.call(val) === \"[object Date]\";\n}\n","// src/SaleorRefreshTokenStorageHandler.ts\nvar getStorageAuthEventKey = (prefix) => [prefix, \"saleor_storage_auth_change\"].filter(Boolean).join(\"+\");\nvar getStorageAuthStateKey = (prefix) => [prefix, \"saleor_auth_module_auth_state\"].filter(Boolean).join(\"+\");\nvar getRefreshTokenKey = (prefix) => [prefix, \"saleor_auth_module_refresh_token\"].filter(Boolean).join(\"+\");\nvar SaleorRefreshTokenStorageHandler = class {\n  constructor(storage, prefix) {\n    this.storage = storage;\n    this.prefix = prefix;\n    if (typeof window !== \"undefined\") {\n      window.addEventListener(\"storage\", this.handleStorageChange);\n    }\n  }\n  handleStorageChange = (event) => {\n    const { oldValue, newValue, type, key } = event;\n    if (oldValue === newValue || type !== \"storage\" || key !== getStorageAuthStateKey(this.prefix)) {\n      return;\n    }\n    this.sendAuthStateEvent(newValue);\n  };\n  cleanup = () => {\n    if (typeof window !== \"undefined\") {\n      window.removeEventListener(\"storage\", this.handleStorageChange);\n    }\n  };\n  /* auth state */\n  sendAuthStateEvent = (authState) => {\n    if (typeof window !== \"undefined\") {\n      const event = new CustomEvent(getStorageAuthEventKey(this.prefix), {\n        detail: { authState }\n      });\n      window.dispatchEvent(event);\n    }\n  };\n  getAuthState = () => this.storage.getItem(getStorageAuthStateKey(this.prefix)) || \"signedOut\";\n  setAuthState = (authState) => {\n    this.storage.setItem(getStorageAuthStateKey(this.prefix), authState);\n    this.sendAuthStateEvent(authState);\n  };\n  /* refresh token */\n  getRefreshToken = () => this.storage.getItem(getRefreshTokenKey(this.prefix)) || null;\n  setRefreshToken = (token) => {\n    this.storage.setItem(getRefreshTokenKey(this.prefix), token);\n  };\n  /* performed on logout */\n  clearAuthStorage = () => {\n    this.setAuthState(\"signedOut\");\n    this.storage.removeItem(getRefreshTokenKey(this.prefix));\n  };\n};\n\nexport {\n  getStorageAuthEventKey,\n  getStorageAuthStateKey,\n  getRefreshTokenKey,\n  SaleorRefreshTokenStorageHandler\n};\n","/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n  return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nvar ownKeys = function(o) {\n  ownKeys = Object.getOwnPropertyNames || function (o) {\n    var ar = [];\n    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n    return ar;\n  };\n  return ownKeys(o);\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport function __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose, inner;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n      if (async) inner = dispose;\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nexport function __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  var r, s = 0;\n  function next() {\n    while (r = env.stack.pop()) {\n      try {\n        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n        if (r.dispose) {\n          var result = r.dispose.call(r.value);\n          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n        }\n        else s |= 1;\n      }\n      catch (e) {\n        fail(e);\n      }\n    }\n    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\n  if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\n      return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\n          return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\n      });\n  }\n  return path;\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __esDecorate,\n  __runInitializers,\n  __propKey,\n  __setFunctionName,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n  __rewriteRelativeImportExtension,\n};\n","// src/SaleorAccessTokenStorageHandler.ts\nvar getAccessTokenKey = (prefix) => [prefix, \"saleor_auth_access_token\"].filter(Boolean).join(\"+\");\nvar SaleorAccessTokenStorageHandler = class {\n  constructor(storage, prefix) {\n    this.storage = storage;\n    this.prefix = prefix;\n  }\n  getAccessToken = () => {\n    const key = getAccessTokenKey(this.prefix);\n    return this.storage.getItem(key);\n  };\n  setAccessToken = (token) => {\n    const key = getAccessTokenKey(this.prefix);\n    return this.storage.setItem(key, token);\n  };\n  clearAuthStorage = () => {\n    const key = getAccessTokenKey(this.prefix);\n    return this.storage.removeItem(key);\n  };\n};\n\nexport {\n  getAccessTokenKey,\n  SaleorAccessTokenStorageHandler\n};\n","// src/utils.ts\nvar MILLI_MULTIPLYER = 1e3;\nvar decodeToken = (token) => {\n  const tokenParts = token.split(\".\");\n  const decodedTokenData = Buffer.from(tokenParts[1] || \"\", \"base64\").toString();\n  const parsedTokenData = JSON.parse(decodedTokenData);\n  return parsedTokenData;\n};\nvar getTokenExpiry = (token) => {\n  const parsedTokenData = decodeToken(token);\n  return parsedTokenData.exp * MILLI_MULTIPLYER || 0;\n};\nvar getTokenIss = (token) => {\n  const parsedTokenData = decodeToken(token);\n  return parsedTokenData.iss;\n};\nvar isExpiredToken = (token, tokenGracePeriod) => {\n  return getTokenExpiry(token) - tokenGracePeriod <= Date.now();\n};\nvar getRequestData = (query, variables, requestInit) => ({\n  ...requestInit,\n  method: \"POST\",\n  headers: {\n    \"Content-Type\": \"application/json\"\n  },\n  body: JSON.stringify({\n    query,\n    variables\n  })\n});\nvar InvariantError = class extends Error {\n  constructor(message) {\n    super(message);\n  }\n};\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new InvariantError(`Invariant Violation: ${message || \"\"}`);\n  }\n}\n\nexport {\n  getTokenIss,\n  isExpiredToken,\n  getRequestData,\n  InvariantError,\n  invariant\n};\n","// src/graphql.ts\nvar TypedDocumentString = class extends String {\n  constructor(value, __meta__) {\n    super(value);\n    this.value = value;\n    this.__meta__ = __meta__;\n  }\n  __apiType;\n  toString() {\n    return this.value;\n  }\n};\n\nexport {\n  TypedDocumentString\n};\n","// src/react/context.ts\nimport { createContext, useContext } from \"react\";\nvar createSafeContext = () => {\n  const context = createContext(void 0);\n  function useSafeContext() {\n    const value = useContext(context);\n    if (value === void 0) {\n      throw new Error(\"useContext must be inside a Provider with a value\");\n    }\n    return value;\n  }\n  return [useSafeContext, context.Provider];\n};\nvar [useSaleorAuthContext, Provider] = createSafeContext();\n\nexport {\n  createSafeContext,\n  useSaleorAuthContext,\n  Provider\n};\n","\"use client\";\r\n\r\nimport { SaleorAuthProvider, useAuthChange } from \"@saleor/auth-sdk/react\";\r\nimport { invariant } from \"ts-invariant\";\r\nimport { createSaleorAuthClient } from \"@saleor/auth-sdk\";\r\nimport { useState, type ReactNode } from \"react\";\r\nimport {\r\n\ttype Client,\r\n\tProvider as UrqlProvider,\r\n\tcacheExchange,\r\n\tcreateClient,\r\n\tdedupExchange,\r\n\tfetchExchange,\r\n} from \"urql\";\r\n\r\nconst saleorApiUrl = process.env.NEXT_PUBLIC_SALEOR_API_URL;\r\ninvariant(saleorApiUrl, \"Missing NEXT_PUBLIC_SALEOR_API_URL env variable\");\r\n\r\nexport const saleorAuthClient = createSaleorAuthClient({\r\n\tsaleorApiUrl,\r\n});\r\n\r\nconst makeUrqlClient = () => {\r\n\treturn createClient({\r\n\t\turl: saleorApiUrl,\r\n\t\tsuspense: true,\r\n\t\t// requestPolicy: \"cache-first\",\r\n\t\tfetch: (input, init) => saleorAuthClient.fetchWithAuth(input as NodeJS.fetch.RequestInfo, init),\r\n\t\texchanges: [dedupExchange, cacheExchange, fetchExchange],\r\n\t});\r\n};\r\n\r\nexport function AuthProvider({ children }: { children: ReactNode }) {\r\n\tinvariant(saleorApiUrl, \"Missing NEXT_PUBLIC_SALEOR_API_URL env variable\");\r\n\r\n\tconst [urqlClient, setUrqlClient] = useState<Client>(() => makeUrqlClient());\r\n\tuseAuthChange({\r\n\t\tsaleorApiUrl,\r\n\t\tonSignedOut: () => {\r\n\t\t\tsetUrqlClient(makeUrqlClient());\r\n\t\t},\r\n\t\tonSignedIn: () => {\r\n\t\t\tsetUrqlClient(makeUrqlClient());\r\n\t\t},\r\n\t});\r\n\r\n\treturn (\r\n\t\t<SaleorAuthProvider client={saleorAuthClient}>\r\n\t\t\t<UrqlProvider value={urqlClient}>{children}</UrqlProvider>\r\n\t\t</SaleorAuthProvider>\r\n\t);\r\n}\r\n","export const Kind = {\n  NAME: 'Name',\n  DOCUMENT: 'Document',\n  OPERATION_DEFINITION: 'OperationDefinition',\n  VARIABLE_DEFINITION: 'VariableDefinition',\n  SELECTION_SET: 'SelectionSet',\n  FIELD: 'Field',\n  ARGUMENT: 'Argument',\n  FRAGMENT_SPREAD: 'FragmentSpread',\n  INLINE_FRAGMENT: 'InlineFragment',\n  FRAGMENT_DEFINITION: 'FragmentDefinition',\n  VARIABLE: 'Variable',\n  INT: 'IntValue',\n  FLOAT: 'FloatValue',\n  STRING: 'StringValue',\n  BOOLEAN: 'BooleanValue',\n  NULL: 'NullValue',\n  ENUM: 'EnumValue',\n  LIST: 'ListValue',\n  OBJECT: 'ObjectValue',\n  OBJECT_FIELD: 'ObjectField',\n  DIRECTIVE: 'Directive',\n  NAMED_TYPE: 'NamedType',\n  LIST_TYPE: 'ListType',\n  NON_NULL_TYPE: 'NonNullType',\n\n  /*\n  SCHEMA_DEFINITION: 'SchemaDefinition',\n  OPERATION_TYPE_DEFINITION: 'OperationTypeDefinition',\n  SCALAR_TYPE_DEFINITION: 'ScalarTypeDefinition',\n  OBJECT_TYPE_DEFINITION: 'ObjectTypeDefinition',\n  FIELD_DEFINITION: 'FieldDefinition',\n  INPUT_VALUE_DEFINITION: 'InputValueDefinition',\n  INTERFACE_TYPE_DEFINITION: 'InterfaceTypeDefinition',\n  UNION_TYPE_DEFINITION: 'UnionTypeDefinition',\n  ENUM_TYPE_DEFINITION: 'EnumTypeDefinition',\n  ENUM_VALUE_DEFINITION: 'EnumValueDefinition',\n  INPUT_OBJECT_TYPE_DEFINITION: 'InputObjectTypeDefinition',\n  DIRECTIVE_DEFINITION: 'DirectiveDefinition',\n  SCHEMA_EXTENSION: 'SchemaExtension',\n  SCALAR_TYPE_EXTENSION: 'ScalarTypeExtension',\n  OBJECT_TYPE_EXTENSION: 'ObjectTypeExtension',\n  INTERFACE_TYPE_EXTENSION: 'InterfaceTypeExtension',\n  UNION_TYPE_EXTENSION: 'UnionTypeExtension',\n  ENUM_TYPE_EXTENSION: 'EnumTypeExtension',\n  INPUT_OBJECT_TYPE_EXTENSION: 'InputObjectTypeExtension',\n  */\n};\n\nexport const OperationTypeNode = {\n  QUERY: 'query',\n  MUTATION: 'mutation',\n  SUBSCRIPTION: 'subscription',\n};\n","const genericMessage = \"Invariant Violation\";\nconst {\n  setPrototypeOf = function (obj: any, proto: any) {\n    obj.__proto__ = proto;\n    return obj;\n  },\n} = Object as any;\n\nexport class InvariantError extends Error {\n  framesToPop = 1;\n  name = genericMessage;\n  constructor(message: string | number = genericMessage) {\n    super(\n      typeof message === \"number\"\n        ? `${genericMessage}: ${message} (see https://github.com/apollographql/invariant-packages)`\n        : message\n    );\n    setPrototypeOf(this, InvariantError.prototype);\n  }\n}\n\nexport function invariant(\n  condition: any,\n  message?: string | number,\n): asserts condition {\n  if (!condition) {\n    throw new InvariantError(message);\n  }\n}\n\nconst verbosityLevels = [\"debug\", \"log\", \"warn\", \"error\", \"silent\"] as const;\nexport type VerbosityLevel = (typeof verbosityLevels)[number];\nexport type ConsoleMethodName = Exclude<VerbosityLevel, \"silent\">;\nlet verbosityLevel = verbosityLevels.indexOf(\"log\");\n\nfunction wrapConsoleMethod<M extends ConsoleMethodName>(name: M) {\n  return function () {\n    if (verbosityLevels.indexOf(name) >= verbosityLevel) {\n      // Default to console.log if this host environment happens not to provide\n      // all the console.* methods we need.\n      const method = console[name] || console.log;\n      return method.apply(console, arguments as any);\n    }\n  } as (typeof console)[M];\n}\n\nexport namespace invariant {\n  export const debug = wrapConsoleMethod(\"debug\");\n  export const log = wrapConsoleMethod(\"log\");\n  export const warn = wrapConsoleMethod(\"warn\");\n  export const error = wrapConsoleMethod(\"error\");\n}\n\nexport function setVerbosity(level: VerbosityLevel): VerbosityLevel {\n  const old = verbosityLevels[verbosityLevel];\n  verbosityLevel = Math.max(0, verbosityLevels.indexOf(level));\n  return old;\n}\n\nexport default invariant;\n","import {\n  TypedDocumentString\n} from \"./chunk-K5MTKW5C.mjs\";\n\n// src/mutations.ts\nvar accountErrorFragment = (\n  /* graphql */\n  `\n  fragment AccountErrorFragment on AccountError {\n    code\n    field\n    message\n  }\n`\n);\nvar TOKEN_REFRESH = new TypedDocumentString(\n  /* graphql */\n  `\n  ${accountErrorFragment}\n  mutation refreshToken($refreshToken: String!) {\n    tokenRefresh(refreshToken: $refreshToken) {\n      token\n      errors {\n        ...AccountErrorFragment\n      }\n    }\n  }\n`\n);\nvar TOKEN_CREATE = new TypedDocumentString(\n  /* graphql */\n  `\n  mutation tokenCreate($email: String!, $password: String!) {\n    tokenCreate(email: $email, password: $password) {\n      token\n      refreshToken\n      errors {\n        message\n        field\n        code\n      }\n    }\n  }\n`\n);\nvar PASSWORD_RESET = new TypedDocumentString(\n  /* graphql */\n  `\n  mutation passwordReset($email: String!, $password: String!, $token: String!) {\n    setPassword(email: $email, password: $password, token: $token) {\n      token\n      refreshToken\n      errors {\n        message\n        field\n        code\n      }\n    }\n  }\n`\n);\nvar ExternalAuthenticationURL = new TypedDocumentString(\n  /* graphql */\n  `\n  mutation externalAuthenticationUrl($pluginId: String!, $input: JSONString!) {\n    externalAuthenticationUrl(pluginId: $pluginId, input: $input) {\n      authenticationData\n      errors {\n        code\n        field\n        message\n      }\n    }\n  }\n`\n);\nvar ExternalObtainAccessTokens = new TypedDocumentString(\n  /* graphql */\n  `\n  mutation AuthObtainAccessToken($pluginId: String!, $input: JSONString!) {\n    externalObtainAccessTokens(pluginId: $pluginId, input: $input) {\n      token\n      refreshToken\n      user {\n        id\n        email\n      }\n      errors {\n        field\n        code\n        message\n      }\n    }\n  }\n`\n);\n\nexport {\n  accountErrorFragment,\n  TOKEN_REFRESH,\n  TOKEN_CREATE,\n  PASSWORD_RESET,\n  ExternalAuthenticationURL,\n  ExternalObtainAccessTokens\n};\n","import { GraphQLError } from '@0no-co/graphql.web';\nimport type { ErrorLike } from '../types';\n\nconst generateErrorMessage = (\n  networkErr?: Error,\n  graphQlErrs?: GraphQLError[]\n) => {\n  let error = '';\n  if (networkErr) return `[Network] ${networkErr.message}`;\n  if (graphQlErrs) {\n    for (const err of graphQlErrs) {\n      if (error) error += '\\n';\n      error += `[GraphQL] ${err.message}`;\n    }\n  }\n  return error;\n};\n\nconst rehydrateGraphQlError = (error: any): GraphQLError => {\n  if (\n    error &&\n    error.message &&\n    (error.extensions || error.name === 'GraphQLError')\n  ) {\n    return error;\n  } else if (typeof error === 'object' && error.message) {\n    return new GraphQLError(\n      error.message,\n      error.nodes,\n      error.source,\n      error.positions,\n      error.path,\n      error,\n      error.extensions || {}\n    );\n  } else {\n    return new GraphQLError(error as any);\n  }\n};\n\n/** An abstracted `Error` that provides either a `networkError` or `graphQLErrors`.\n *\n * @remarks\n * During a GraphQL request, either the request can fail entirely, causing a network error,\n * or the GraphQL execution or fields can fail, which will cause an {@link ExecutionResult}\n * to contain an array of GraphQL errors.\n *\n * The `CombinedError` abstracts and normalizes both failure cases. When {@link OperationResult.error}\n * is set to this error, the `CombinedError` abstracts all errors, making it easier to handle only\n * a subset of error cases.\n *\n * @see {@link https://urql.dev/goto/docs/basics/errors} for more information on handling\n * GraphQL errors and the `CombinedError`.\n */\nexport class CombinedError extends Error {\n  public name: string;\n  public message: string;\n\n  /** A list of GraphQL errors rehydrated from a {@link ExecutionResult}.\n   *\n   * @remarks\n   * If an {@link ExecutionResult} received from the API contains a list of errors,\n   * the `CombinedError` will rehydrate them, normalize them to\n   * {@link GraphQLError | GraphQLErrors} and list them here.\n   * An empty list indicates that no GraphQL error has been sent by the API.\n   */\n  public graphQLErrors: GraphQLError[];\n\n  /** Set to an error, if a GraphQL request has failed outright.\n   *\n   * @remarks\n   * A GraphQL over HTTP request may fail and not reach the API. Any error that\n   * prevents a GraphQl request outright, will be considered a network error and\n   * set here.\n   */\n  public networkError?: Error;\n\n  /** Set to the {@link Response} object a fetch exchange received.\n   *\n   * @remarks\n   * If a built-in fetch {@link Exchange} is used in `urql`, this may\n   * be set to the {@link Response} object of the Fetch API response.\n   * However, since `urql` doesnt assume that all users will use HTTP\n   * as the only or exclusive transport for GraphQL this property is\n   * neither typed nor guaranteed and may be re-used for other purposes\n   * by non-fetch exchanges.\n   *\n   * Hint: It can be useful to use `response.status` here, however, if\n   * you plan on relying on this being a {@link Response} in your app,\n   * which it is by default, then make sure you add some extra checks\n   * before blindly assuming so!\n   */\n  public response?: any;\n\n  constructor(input: {\n    networkError?: Error;\n    graphQLErrors?: Array<string | ErrorLike>;\n    response?: any;\n  }) {\n    const normalizedGraphQLErrors = (input.graphQLErrors || []).map(\n      rehydrateGraphQlError\n    );\n    const message = generateErrorMessage(\n      input.networkError,\n      normalizedGraphQLErrors\n    );\n\n    super(message);\n\n    this.name = 'CombinedError';\n    this.message = message;\n    this.graphQLErrors = normalizedGraphQLErrors;\n    this.networkError = input.networkError;\n    this.response = input.response;\n  }\n\n  toString() {\n    return this.message;\n  }\n}\n","import {\n  Provider\n} from \"./chunk-NAQNA6DI.mjs\";\n\n// src/react/SaleorAuthProvider.tsx\nimport { jsx } from \"react/jsx-runtime\";\nvar SaleorAuthProvider = ({ children, client }) => {\n  return /* @__PURE__ */ jsx(Provider, { value: client, children });\n};\n\nexport {\n  SaleorAuthProvider\n};\n","import {\n  getStorageAuthEventKey\n} from \"./chunk-263DHBMK.mjs\";\n\n// src/react/useAuthChange.ts\nimport { useEffect } from \"react\";\nvar useAuthChange = ({ saleorApiUrl, onSignedOut, onSignedIn }) => {\n  const handleAuthChange = (event) => {\n    const isCustomAuthEvent = event?.type === getStorageAuthEventKey(saleorApiUrl);\n    if (!isCustomAuthEvent) {\n      return;\n    }\n    const { authState } = event.detail;\n    if (authState === \"signedIn\") {\n      onSignedIn?.();\n    } else if (authState === \"signedOut\") {\n      onSignedOut?.();\n    }\n  };\n  useEffect(() => {\n    if (typeof window === \"undefined\") {\n      return;\n    }\n    window.addEventListener(getStorageAuthEventKey(saleorApiUrl), handleAuthChange);\n    return () => {\n      window.removeEventListener(getStorageAuthEventKey(saleorApiUrl), handleAuthChange);\n    };\n  }, []);\n};\n\nexport {\n  useAuthChange\n};\n","interface EntityLike {\n  [key: string]: EntityLike | EntityLike[] | any;\n  __typename: string | null | void;\n}\n\nconst collectTypes = (obj: EntityLike | EntityLike[], types: Set<string>) => {\n  if (Array.isArray(obj)) {\n    for (const item of obj) collectTypes(item, types);\n  } else if (typeof obj === 'object' && obj !== null) {\n    for (const key in obj) {\n      if (key === '__typename' && typeof obj[key] === 'string') {\n        types.add(obj[key] as string);\n      } else {\n        collectTypes(obj[key], types);\n      }\n    }\n  }\n\n  return types;\n};\n\n/** Finds and returns a list of `__typename` fields found in response data.\n *\n * @privateRemarks\n * This is used by `@urql/core`s document `cacheExchange` to find typenames\n * in a given GraphQL responses data.\n */\nexport const collectTypenames = (response: object): string[] => [\n  ...collectTypes(response as EntityLike, new Set()),\n];\n","import * as React from 'react';\nimport type { Client } from '@urql/core';\n\nconst OBJ = {};\n\n/** `urql`'s React Context.\n *\n * @remarks\n * The React Context that `urql`s {@link Client} will be provided with.\n * You may use the reexported {@link Provider} to provide a `Client` as well.\n */\nexport const Context: import('react').Context<Client | object> =\n  React.createContext(OBJ);\n\n/** Provider for `urql`'s {@link Client} to GraphQL hooks.\n *\n * @remarks\n * `Provider` accepts a {@link Client} and provides it to all GraphQL hooks,\n * and {@link useClient}.\n *\n * You should make sure to create a {@link Client} and provide it with the\n * `Provider` to parts of your component tree that use GraphQL hooks.\n *\n * @example\n * ```tsx\n * import { Provider } from 'urql';\n * // All of `@urql/core` is also re-exported by `urql`:\n * import { Client, cacheExchange, fetchExchange } from '@urql/core';\n *\n * const client = new Client({\n *   url: 'https://API',\n *   exchanges: [cacheExchange, fetchExchange],\n * });\n *\n * const App = () => (\n *   <Provider value={client}>\n *     <Component />\n *   </Provider>\n * );\n * ```\n */\nexport const Provider: React.Provider<Client | object> = Context.Provider;\n\n/** React Consumer component, providing the {@link Client} provided on a parent component.\n * @remarks\n * This is an alias for {@link Context.Consumer}.\n */\nexport const Consumer: React.Consumer<Client | object> = Context.Consumer;\n\nContext.displayName = 'UrqlContext';\n\n/** Hook returning a {@link Client} from {@link Context}.\n *\n * @remarks\n * `useClient` is a convenience hook, which accesses `urql`'s {@link Context}\n * and returns the {@link Client} defined on it.\n *\n * This will be the {@link Client} you passed to a {@link Provider}\n * you wrapped your elements containing this hook with.\n *\n * @throws\n * In development, if the component you call `useClient()` in is\n * not wrapped in a {@link Provider}, an error is thrown.\n */\nexport const useClient = (): Client => {\n  const client = React.useContext(Context);\n\n  if (client === OBJ && process.env.NODE_ENV !== 'production') {\n    const error =\n      \"No client has been specified using urql's Provider. please create a client and add a Provider.\";\n\n    console.error(error);\n    throw new Error(error);\n  }\n\n  return client as Client;\n};\n","import {\n  SaleorAccessTokenStorageHandler\n} from \"./chunk-BZFBMGPG.mjs\";\nimport {\n  SaleorRefreshTokenStorageHandler\n} from \"./chunk-263DHBMK.mjs\";\nimport {\n  getRequestData,\n  getTokenIss,\n  invariant,\n  isExpiredToken\n} from \"./chunk-IRFIDVVY.mjs\";\nimport {\n  PASSWORD_RESET,\n  TOKEN_CREATE,\n  TOKEN_REFRESH\n} from \"./chunk-7JTFMRQS.mjs\";\n\n// src/SaleorAuthClient.ts\nimport cookie from \"cookie\";\nvar SaleorAuthClient = class {\n  // we'll assume a generous time of 2 seconds for api to\n  // process our request\n  tokenGracePeriod = 2e3;\n  tokenRefreshPromise = null;\n  onAuthRefresh;\n  saleorApiUrl;\n  /**\n   * Persistent storage (for refresh token)\n   */\n  refreshTokenStorage;\n  /**\n   * Non-persistent storage for access token\n   */\n  accessTokenStorage;\n  defaultRequestInit;\n  /**\n   * Use ths method to clear event listeners from storageHandler\n   *  @example\n   *  ```jsx\n   *  useEffect(() => {\n   *    return () => {\n   *      SaleorAuthClient.cleanup();\n   *    }\n   *  }, [])\n   *  ```\n   */\n  constructor({\n    saleorApiUrl,\n    refreshTokenStorage,\n    accessTokenStorage,\n    onAuthRefresh,\n    tokenGracePeriod,\n    defaultRequestInit\n  }) {\n    this.defaultRequestInit = defaultRequestInit;\n    if (tokenGracePeriod) {\n      this.tokenGracePeriod = tokenGracePeriod;\n    }\n    this.onAuthRefresh = onAuthRefresh;\n    this.saleorApiUrl = saleorApiUrl;\n    const refreshTokenRepo = refreshTokenStorage ?? (typeof window !== \"undefined\" ? window.localStorage : void 0);\n    this.refreshTokenStorage = refreshTokenRepo ? new SaleorRefreshTokenStorageHandler(refreshTokenRepo, saleorApiUrl) : null;\n    const accessTokenRepo = accessTokenStorage ?? getInMemoryAccessTokenStorage();\n    this.accessTokenStorage = new SaleorAccessTokenStorageHandler(accessTokenRepo, saleorApiUrl);\n  }\n  cleanup = () => {\n    this.refreshTokenStorage?.cleanup();\n  };\n  runAuthorizedRequest = (input, init, additionalParams) => {\n    const token = this.accessTokenStorage.getAccessToken();\n    if (!token) {\n      return fetch(input, init);\n    }\n    const headers = init?.headers || {};\n    const getURL = (input2) => {\n      if (typeof input2 === \"string\") {\n        return input2;\n      } else if (\"url\" in input2) {\n        return input2.url;\n      } else {\n        return input2.href;\n      }\n    };\n    const iss = getTokenIss(token);\n    const issuerAndDomainMatch = getURL(input) === iss;\n    const shouldAddAuthorizationHeader = issuerAndDomainMatch || additionalParams?.allowPassingTokenToThirdPartyDomains;\n    if (!issuerAndDomainMatch) {\n      if (shouldAddAuthorizationHeader) {\n        console.warn(\n          \"Token's `iss` and request URL do not match but `allowPassingTokenToThirdPartyDomains` was specified.\"\n        );\n      } else {\n        console.warn(\n          \"Token's `iss` and request URL do not match. Not adding `Authorization` header to the request.\"\n        );\n      }\n    }\n    return fetch(input, {\n      ...init,\n      headers: shouldAddAuthorizationHeader ? { ...headers, Authorization: `Bearer ${token}` } : headers\n    });\n  };\n  handleRequestWithTokenRefresh = async (input, requestInit, additionalParams) => {\n    const refreshToken = this.refreshTokenStorage?.getRefreshToken();\n    invariant(refreshToken, \"Missing refresh token in token refresh handler\");\n    const accessToken = this.accessTokenStorage.getAccessToken();\n    if (accessToken && !isExpiredToken(accessToken, this.tokenGracePeriod)) {\n      return this.fetchWithAuth(input, requestInit, additionalParams);\n    }\n    this.onAuthRefresh?.(true);\n    if (this.tokenRefreshPromise) {\n      const response = await this.tokenRefreshPromise;\n      const res = await response.clone().json();\n      const {\n        errors: graphqlErrors,\n        data: {\n          tokenRefresh: { errors, token }\n        }\n      } = res;\n      this.onAuthRefresh?.(false);\n      if (errors?.length || graphqlErrors?.length || !token) {\n        this.tokenRefreshPromise = null;\n        this.refreshTokenStorage?.clearAuthStorage();\n        return fetch(input, requestInit);\n      }\n      this.refreshTokenStorage?.setAuthState(\"signedIn\");\n      this.accessTokenStorage.setAccessToken(token);\n      this.tokenRefreshPromise = null;\n      return this.runAuthorizedRequest(input, requestInit, additionalParams);\n    }\n    this.tokenRefreshPromise = fetch(\n      this.saleorApiUrl,\n      getRequestData(TOKEN_REFRESH, { refreshToken }, { ...this.defaultRequestInit, ...requestInit })\n    );\n    return this.fetchWithAuth(input, requestInit, additionalParams);\n  };\n  handleSignIn = async (response) => {\n    const readResponse = await response.json();\n    const responseData = \"tokenCreate\" in readResponse.data ? readResponse.data.tokenCreate : readResponse.data.setPassword;\n    if (!responseData) {\n      return readResponse;\n    }\n    const { errors, token, refreshToken } = responseData;\n    if (!token || errors.length) {\n      this.refreshTokenStorage?.setAuthState(\"signedOut\");\n      return readResponse;\n    }\n    if (token) {\n      this.accessTokenStorage.setAccessToken(token);\n    }\n    if (refreshToken) {\n      this.refreshTokenStorage?.setRefreshToken(refreshToken);\n    }\n    this.refreshTokenStorage?.setAuthState(\"signedIn\");\n    return readResponse;\n  };\n  /**\n   * @param additionalParams\n   * @param additionalParams.allowPassingTokenToThirdPartyDomains if set to true, the `Authorization` header will be added to the request even if the token's `iss` and request URL do not match\n   */\n  fetchWithAuth = async (input, init, additionalParams) => {\n    const refreshToken = this.refreshTokenStorage?.getRefreshToken();\n    if (!this.accessTokenStorage.getAccessToken() && typeof document !== \"undefined\") {\n      const tokenFromCookie = cookie.parse(document.cookie).token ?? null;\n      if (tokenFromCookie) {\n        this.accessTokenStorage.setAccessToken(tokenFromCookie);\n      }\n      document.cookie = cookie.serialize(\"token\", \"\", { expires: /* @__PURE__ */ new Date(0), path: \"/\" });\n    }\n    const accessToken = this.accessTokenStorage.getAccessToken();\n    if (accessToken && !isExpiredToken(accessToken, this.tokenGracePeriod)) {\n      return this.runAuthorizedRequest(input, init, additionalParams);\n    }\n    if (refreshToken) {\n      return this.handleRequestWithTokenRefresh(input, init, additionalParams);\n    }\n    return fetch(input, init);\n  };\n  resetPassword = async (variables, requestInit) => {\n    const response = await fetch(\n      this.saleorApiUrl,\n      getRequestData(PASSWORD_RESET, variables, { ...this.defaultRequestInit, ...requestInit })\n    );\n    return this.handleSignIn(response);\n  };\n  signIn = async (variables, requestInit) => {\n    const response = await fetch(\n      this.saleorApiUrl,\n      getRequestData(TOKEN_CREATE, variables, { ...this.defaultRequestInit, ...requestInit })\n    );\n    return this.handleSignIn(response);\n  };\n  signOut = () => {\n    this.accessTokenStorage.clearAuthStorage();\n    this.refreshTokenStorage?.clearAuthStorage();\n    if (typeof document !== \"undefined\") {\n      document.cookie = cookie.serialize(\"token\", \"\", {\n        expires: /* @__PURE__ */ new Date(0),\n        path: \"/\"\n      });\n    }\n  };\n};\nvar createSaleorAuthClient = (props) => new SaleorAuthClient(props);\nfunction getInMemoryAccessTokenStorage() {\n  let accessToken = null;\n  return {\n    getItem() {\n      return accessToken;\n    },\n    removeItem() {\n      return accessToken = null;\n    },\n    setItem(_key, value) {\n      return accessToken = value;\n    }\n  };\n}\n\nexport {\n  SaleorAuthClient,\n  createSaleorAuthClient\n};\n","import type {\n  FieldNode,\n  SelectionNode,\n  DefinitionNode,\n  DirectiveNode,\n} from '@0no-co/graphql.web';\nimport { Kind } from '@0no-co/graphql.web';\nimport type { KeyedDocumentNode } from './request';\nimport { keyDocument } from './request';\nimport type { FormattedNode, TypedDocumentNode } from '../types';\n\nconst formatNode = <\n  T extends SelectionNode | DefinitionNode | TypedDocumentNode<any, any>,\n>(\n  node: T\n): FormattedNode<T> => {\n  if ('definitions' in node) {\n    const definitions: FormattedNode<DefinitionNode>[] = [];\n    for (const definition of node.definitions) {\n      const newDefinition = formatNode(definition);\n      definitions.push(newDefinition);\n    }\n\n    return { ...node, definitions } as FormattedNode<T>;\n  }\n\n  if ('directives' in node && node.directives && node.directives.length) {\n    const directives: DirectiveNode[] = [];\n    const _directives = {};\n    for (const directive of node.directives) {\n      let name = directive.name.value;\n      if (name[0] !== '_') {\n        directives.push(directive);\n      } else {\n        name = name.slice(1);\n      }\n      _directives[name] = directive;\n    }\n    node = { ...node, directives, _directives };\n  }\n\n  if ('selectionSet' in node) {\n    const selections: FormattedNode<SelectionNode>[] = [];\n    let hasTypename = node.kind === Kind.OPERATION_DEFINITION;\n    if (node.selectionSet) {\n      for (const selection of node.selectionSet.selections || []) {\n        hasTypename =\n          hasTypename ||\n          (selection.kind === Kind.FIELD &&\n            selection.name.value === '__typename' &&\n            !selection.alias);\n        const newSelection = formatNode(selection);\n        selections.push(newSelection);\n      }\n\n      if (!hasTypename) {\n        selections.push({\n          kind: Kind.FIELD,\n          name: {\n            kind: Kind.NAME,\n            value: '__typename',\n          },\n          _generated: true,\n        } as FormattedNode<FieldNode>);\n      }\n\n      return {\n        ...node,\n        selectionSet: { ...node.selectionSet, selections },\n      } as FormattedNode<T>;\n    }\n  }\n\n  return node as FormattedNode<T>;\n};\n\nconst formattedDocs = new Map<number, KeyedDocumentNode>();\n\n/** Formats a GraphQL document to add `__typename` fields and process client-side directives.\n *\n * @param node - a {@link DocumentNode}.\n * @returns a {@link FormattedDocument}\n *\n * @remarks\n * Cache {@link Exchange | Exchanges} will require typename introspection to\n * recognize types in a GraphQL response. To retrieve these typenames,\n * this function is used to add the `__typename` fields to non-root\n * selection sets of a GraphQL document.\n *\n * Additionally, this utility will process directives, filter out client-side\n * directives starting with an `_` underscore, and place a `_directives` dictionary\n * on selection nodes.\n *\n * This utility also preserves the internally computed key of the\n * document as created by {@link createRequest} to avoid any\n * formatting from being duplicated.\n *\n * @see {@link https://spec.graphql.org/October2021/#sec-Type-Name-Introspection} for more information\n * on typename introspection via the `__typename` field.\n */\nexport const formatDocument = <T extends TypedDocumentNode<any, any>>(\n  node: T\n): FormattedNode<T> => {\n  const query = keyDocument(node);\n\n  let result = formattedDocs.get(query.__key);\n  if (!result) {\n    formattedDocs.set(\n      query.__key,\n      (result = formatNode(query) as KeyedDocumentNode)\n    );\n    // Ensure that the hash of the resulting document won't suddenly change\n    // we are marking __key as non-enumerable so when external exchanges use visit\n    // to manipulate a document we won't restore the previous query due to the __key\n    // property.\n    Object.defineProperty(result, '__key', {\n      value: query.__key,\n      enumerable: false,\n    });\n  }\n\n  return result as FormattedNode<T>;\n};\n","import * as React from 'react';\n\nexport const initialState = {\n  fetching: false,\n  stale: false,\n  error: undefined,\n  data: undefined,\n  extensions: undefined,\n  operation: undefined,\n};\n\n// Two operations are considered equal if they have the same key\nconst areOperationsEqual = (\n  a: { key: number } | undefined,\n  b: { key: number } | undefined\n) => {\n  return a === b || !!(a && b && a.key === b.key);\n};\n\n/**\n * Checks if two objects are shallowly different with a special case for\n * 'operation' where it compares the key if they are not the otherwise equal\n */\nconst isShallowDifferent = <T extends Record<string, any>>(a: T, b: T) => {\n  for (const key in a) if (!(key in b)) return true;\n  for (const key in b) {\n    if (\n      key === 'operation'\n        ? !areOperationsEqual(a[key], b[key])\n        : a[key] !== b[key]\n    ) {\n      return true;\n    }\n  }\n  return false;\n};\n\ninterface Stateish {\n  data?: any;\n  error?: any;\n  fetching: boolean;\n  stale: boolean;\n}\n\nexport const computeNextState = <T extends Stateish>(\n  prevState: T,\n  result: Partial<T>\n): T => {\n  const newState: T = {\n    ...prevState,\n    ...result,\n    data:\n      result.data !== undefined || result.error ? result.data : prevState.data,\n    fetching: !!result.fetching,\n    stale: !!result.stale,\n  };\n\n  return isShallowDifferent(prevState, newState) ? newState : prevState;\n};\n\nexport const hasDepsChanged = <T extends { length: number }>(a: T, b: T) => {\n  for (let i = 0, l = b.length; i < l; i++) if (a[i] !== b[i]) return true;\n  return false;\n};\n\nconst reactSharedInternals = (React as any)\n  .__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nexport function deferDispatch<Dispatch extends React.Dispatch<any>>(\n  setState: Dispatch,\n  value: Dispatch extends React.Dispatch<infer State> ? State : void\n) {\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    !!reactSharedInternals &&\n    !!reactSharedInternals.ReactCurrentOwner &&\n    !!reactSharedInternals.ReactCurrentOwner.current\n  ) {\n    Promise.resolve(value).then(setState);\n  } else {\n    setState(value);\n  }\n}\n","import type { Maybe, Extensions, Source } from './types';\nimport type { ASTNode } from './ast';\n\nexport class GraphQLError extends Error {\n  readonly locations: ReadonlyArray<any> | undefined;\n  readonly path: ReadonlyArray<string | number> | undefined;\n  readonly nodes: ReadonlyArray<any> | undefined;\n  readonly source: Source | undefined;\n  readonly positions: ReadonlyArray<number> | undefined;\n  readonly originalError: Error | undefined;\n  readonly extensions: Extensions;\n\n  constructor(\n    message: string,\n    nodes?: ReadonlyArray<ASTNode> | ASTNode | null,\n    source?: Maybe<Source>,\n    positions?: Maybe<ReadonlyArray<number>>,\n    path?: Maybe<ReadonlyArray<string | number>>,\n    originalError?: Maybe<Error>,\n    extensions?: Maybe<Extensions>\n  ) {\n    super(message);\n\n    this.name = 'GraphQLError';\n    this.message = message;\n\n    if (path) this.path = path;\n    if (nodes) this.nodes = (Array.isArray(nodes) ? nodes : [nodes]) as ASTNode[];\n    if (source) this.source = source;\n    if (positions) this.positions = positions;\n    if (originalError) this.originalError = originalError;\n\n    let _extensions = extensions;\n    if (!_extensions && originalError) {\n      const originalExtensions = (originalError as any).extensions;\n      if (originalExtensions && typeof originalExtensions === 'object') {\n        _extensions = originalExtensions;\n      }\n    }\n\n    this.extensions = _extensions || {};\n  }\n\n  toJSON(): any {\n    return { ...this, message: this.message };\n  }\n\n  toString() {\n    return this.message;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLError';\n  }\n}\n","/** A hash value as computed by {@link phash}.\n *\n * @remarks\n * Typically `HashValue`s are used as hashes and keys of GraphQL documents,\n * variables, and combined, for GraphQL requests.\n */\nexport type HashValue = number & {\n  /** Marker to indicate that a `HashValue` may not be created by a user.\n   *\n   * @remarks\n   * `HashValue`s are created by {@link phash} and are marked as such to not mix them\n   * up with other numbers and prevent them from being created or used outside of this\n   * hashing function.\n   *\n   * @internal\n   */\n  readonly _opaque: unique symbol;\n};\n\n/** Computes a djb2 hash of the given string.\n *\n * @param x - the string to be hashed\n * @param seed - optionally a prior hash for progressive hashing\n * @returns a hash value, i.e. a number\n *\n * @remark\n * This is the hashing function used throughout `urql`, primarily to compute\n * {@link Operation.key}.\n *\n * @see {@link http://www.cse.yorku.ca/~oz/hash.html#djb2} for a further description of djb2.\n */\nexport const phash = (x: string, seed?: HashValue): HashValue => {\n  let h = (seed || 5381) | 0;\n  for (let i = 0, l = x.length | 0; i < l; i++)\n    h = (h << 5) + h + x.charCodeAt(i);\n  return h as HashValue;\n};\n","export type FileMap = Map<string, File | Blob>;\n\nconst seen = new Set();\nconst cache = new WeakMap();\n\nconst stringify = (x: any): string => {\n  if (x === null || seen.has(x)) {\n    return 'null';\n  } else if (typeof x !== 'object') {\n    return JSON.stringify(x) || '';\n  } else if (x.toJSON) {\n    return stringify(x.toJSON());\n  } else if (Array.isArray(x)) {\n    let out = '[';\n    for (const value of x) {\n      if (out.length > 1) out += ',';\n      out += stringify(value) || 'null';\n    }\n    out += ']';\n    return out;\n  } else if (\n    (FileConstructor !== NoopConstructor && x instanceof FileConstructor) ||\n    (BlobConstructor !== NoopConstructor && x instanceof BlobConstructor)\n  ) {\n    return 'null';\n  }\n\n  const keys = Object.keys(x).sort();\n  if (\n    !keys.length &&\n    x.constructor &&\n    Object.getPrototypeOf(x).constructor !== Object.prototype.constructor\n  ) {\n    const key = cache.get(x) || Math.random().toString(36).slice(2);\n    cache.set(x, key);\n    return stringify({ __key: key });\n  }\n\n  seen.add(x);\n  let out = '{';\n  for (const key of keys) {\n    const value = stringify(x[key]);\n    if (value) {\n      if (out.length > 1) out += ',';\n      out += stringify(key) + ':' + value;\n    }\n  }\n\n  seen.delete(x);\n  out += '}';\n  return out;\n};\n\nconst extract = (map: FileMap, path: string, x: any) => {\n  if (x == null || typeof x !== 'object' || x.toJSON || seen.has(x)) {\n    /*noop*/\n  } else if (Array.isArray(x)) {\n    for (let i = 0, l = x.length; i < l; i++)\n      extract(map, `${path}.${i}`, x[i]);\n  } else if (x instanceof FileConstructor || x instanceof BlobConstructor) {\n    map.set(path, x as File | Blob);\n  } else {\n    seen.add(x);\n    for (const key of Object.keys(x)) extract(map, `${path}.${key}`, x[key]);\n  }\n};\n\n/** A stable stringifier for GraphQL variables objects.\n *\n * @param x - any JSON-like data.\n * @return A JSON string.\n *\n * @remarks\n * This utility creates a stable JSON string from any passed data,\n * and protects itself from throwing.\n *\n * The JSON string is stable insofar as objects keys are sorted,\n * and instances of non-plain objects are replaced with random keys\n * replacing their values, which remain stable for the objects\n * instance.\n */\nexport const stringifyVariables = (x: any): string => {\n  seen.clear();\n  return stringify(x);\n};\n\nclass NoopConstructor {}\nconst FileConstructor = typeof File !== 'undefined' ? File : NoopConstructor;\nconst BlobConstructor = typeof Blob !== 'undefined' ? Blob : NoopConstructor;\n\nexport const extractFiles = (x: any): FileMap => {\n  const map: FileMap = new Map();\n  if (\n    FileConstructor !== NoopConstructor ||\n    BlobConstructor !== NoopConstructor\n  ) {\n    seen.clear();\n    extract(map, 'variables', x);\n  }\n  return map;\n};\n","/**\n * This is a spec-compliant implementation of a GraphQL query language parser,\n * up-to-date with the October 2021 Edition. Unlike the reference implementation\n * in graphql.js it will only parse the query language, but not the schema\n * language.\n */\nimport type { Kind, OperationTypeNode } from './kind';\nimport { GraphQLError } from './error';\nimport type { Source } from './types';\nimport type * as ast from './ast';\n\nlet input: string;\nlet idx: number;\n\nfunction error(kind: string) {\n  return new GraphQLError(`Syntax Error: Unexpected token at ${idx} in ${kind}`);\n}\n\nfunction advance(pattern: RegExp) {\n  pattern.lastIndex = idx;\n  if (pattern.test(input)) {\n    const match = input.slice(idx, (idx = pattern.lastIndex));\n    return match;\n  }\n}\n\nconst leadingRe = / +(?=[^\\s])/y;\nfunction blockString(string: string) {\n  const lines = string.split('\\n');\n  let out = '';\n  let commonIndent = 0;\n  let firstNonEmptyLine = 0;\n  let lastNonEmptyLine = lines.length - 1;\n  for (let i = 0; i < lines.length; i++) {\n    leadingRe.lastIndex = 0;\n    if (leadingRe.test(lines[i])) {\n      if (i && (!commonIndent || leadingRe.lastIndex < commonIndent))\n        commonIndent = leadingRe.lastIndex;\n      firstNonEmptyLine = firstNonEmptyLine || i;\n      lastNonEmptyLine = i;\n    }\n  }\n  for (let i = firstNonEmptyLine; i <= lastNonEmptyLine; i++) {\n    if (i !== firstNonEmptyLine) out += '\\n';\n    out += lines[i].slice(commonIndent).replace(/\\\\\"\"\"/g, '\"\"\"');\n  }\n  return out;\n}\n\n// Note: This is equivalent to: /(?:[\\s,]*|#[^\\n\\r]*)*/y\nfunction ignored() {\n  for (\n    let char = input.charCodeAt(idx++) | 0;\n    char === 9 /*'\\t'*/ ||\n    char === 10 /*'\\n'*/ ||\n    char === 13 /*'\\r'*/ ||\n    char === 32 /*' '*/ ||\n    char === 35 /*'#'*/ ||\n    char === 44 /*','*/ ||\n    char === 65279 /*'\\ufeff'*/;\n    char = input.charCodeAt(idx++) | 0\n  ) {\n    if (char === 35 /*'#'*/) while ((char = input.charCodeAt(idx++)) !== 10 && char !== 13);\n  }\n  idx--;\n}\n\nconst nameRe = /[_A-Za-z]\\w*/y;\n\n// NOTE: This should be compressed by our build step\n// This merges all possible value parsing into one regular expression\nconst valueRe = new RegExp(\n  '(?:' +\n    // `null`, `true`, and `false` literals (BooleanValue & NullValue)\n    '(null|true|false)|' +\n    // Variables starting with `$` then having a name (VariableNode)\n    '\\\\$(' +\n    nameRe.source +\n    ')|' +\n    // Numbers, starting with int then optionally following with a float part (IntValue and FloatValue)\n    '(-?\\\\d+)((?:\\\\.\\\\d+)?[eE][+-]?\\\\d+|\\\\.\\\\d+)?|' +\n    // Block strings starting with `\"\"\"` until the next unescaped `\"\"\"` (StringValue)\n    '(\"\"\"(?:\"\"\"|(?:[\\\\s\\\\S]*?[^\\\\\\\\])\"\"\"))|' +\n    // Strings starting with `\"` must be on one line (StringValue)\n    '(\"(?:\"|[^\\\\r\\\\n]*?[^\\\\\\\\]\"))|' + // string\n    // Enums are simply names except for our literals (EnumValue)\n    '(' +\n    nameRe.source +\n    '))',\n  'y'\n);\n\n// NOTE: Each of the groups above end up in the RegExpExecArray at the specified indices (starting with 1)\nconst enum ValueGroup {\n  Const = 1,\n  Var,\n  Int,\n  Float,\n  BlockString,\n  String,\n  Enum,\n}\n\ntype ValueExec = RegExpExecArray & {\n  [Prop in ValueGroup]: string | undefined;\n};\n\nconst complexStringRe = /\\\\/g;\n\nfunction value(constant: true): ast.ConstValueNode;\nfunction value(constant: boolean): ast.ValueNode;\n\nfunction value(constant: boolean): ast.ValueNode {\n  let match: string | undefined;\n  let exec: ValueExec | null;\n  valueRe.lastIndex = idx;\n  if (input.charCodeAt(idx) === 91 /*'['*/) {\n    // Lists are checked ahead of time with `[` chars\n    idx++;\n    ignored();\n    const values: ast.ValueNode[] = [];\n    while (input.charCodeAt(idx) !== 93 /*']'*/) values.push(value(constant));\n    idx++;\n    ignored();\n    return {\n      kind: 'ListValue' as Kind.LIST,\n      values,\n    };\n  } else if (input.charCodeAt(idx) === 123 /*'{'*/) {\n    // Objects are checked ahead of time with `{` chars\n    idx++;\n    ignored();\n    const fields: ast.ObjectFieldNode[] = [];\n    while (input.charCodeAt(idx) !== 125 /*'}'*/) {\n      if ((match = advance(nameRe)) == null) throw error('ObjectField');\n      ignored();\n      if (input.charCodeAt(idx++) !== 58 /*':'*/) throw error('ObjectField');\n      ignored();\n      fields.push({\n        kind: 'ObjectField' as Kind.OBJECT_FIELD,\n        name: { kind: 'Name' as Kind.NAME, value: match },\n        value: value(constant),\n      });\n    }\n    idx++;\n    ignored();\n    return {\n      kind: 'ObjectValue' as Kind.OBJECT,\n      fields,\n    };\n  } else if ((exec = valueRe.exec(input) as ValueExec) != null) {\n    // Starting from here, the merged `valueRe` is used\n    idx = valueRe.lastIndex;\n    ignored();\n    if ((match = exec[ValueGroup.Const]) != null) {\n      return match === 'null'\n        ? { kind: 'NullValue' as Kind.NULL }\n        : {\n            kind: 'BooleanValue' as Kind.BOOLEAN,\n            value: match === 'true',\n          };\n    } else if ((match = exec[ValueGroup.Var]) != null) {\n      if (constant) {\n        throw error('Variable');\n      } else {\n        return {\n          kind: 'Variable' as Kind.VARIABLE,\n          name: {\n            kind: 'Name' as Kind.NAME,\n            value: match,\n          },\n        };\n      }\n    } else if ((match = exec[ValueGroup.Int]) != null) {\n      let floatPart: string | undefined;\n      if ((floatPart = exec[ValueGroup.Float]) != null) {\n        return {\n          kind: 'FloatValue' as Kind.FLOAT,\n          value: match + floatPart,\n        };\n      } else {\n        return {\n          kind: 'IntValue' as Kind.INT,\n          value: match,\n        };\n      }\n    } else if ((match = exec[ValueGroup.BlockString]) != null) {\n      return {\n        kind: 'StringValue' as Kind.STRING,\n        value: blockString(match.slice(3, -3)),\n        block: true,\n      };\n    } else if ((match = exec[ValueGroup.String]) != null) {\n      return {\n        kind: 'StringValue' as Kind.STRING,\n        // When strings don't contain escape codes, a simple slice will be enough, otherwise\n        // `JSON.parse` matches GraphQL's string parsing perfectly\n        value: complexStringRe.test(match) ? (JSON.parse(match) as string) : match.slice(1, -1),\n        block: false,\n      };\n    } else if ((match = exec[ValueGroup.Enum]) != null) {\n      return {\n        kind: 'EnumValue' as Kind.ENUM,\n        value: match,\n      };\n    }\n  }\n\n  throw error('Value');\n}\n\nfunction arguments_(constant: boolean): ast.ArgumentNode[] | undefined {\n  if (input.charCodeAt(idx) === 40 /*'('*/) {\n    const args: ast.ArgumentNode[] = [];\n    idx++;\n    ignored();\n    let _name: string | undefined;\n    do {\n      if ((_name = advance(nameRe)) == null) throw error('Argument');\n      ignored();\n      if (input.charCodeAt(idx++) !== 58 /*':'*/) throw error('Argument');\n      ignored();\n      args.push({\n        kind: 'Argument' as Kind.ARGUMENT,\n        name: { kind: 'Name' as Kind.NAME, value: _name },\n        value: value(constant),\n      });\n    } while (input.charCodeAt(idx) !== 41 /*')'*/);\n    idx++;\n    ignored();\n    return args;\n  }\n}\n\nfunction directives(constant: true): ast.ConstDirectiveNode[] | undefined;\nfunction directives(constant: boolean): ast.DirectiveNode[] | undefined;\n\nfunction directives(constant: boolean): ast.DirectiveNode[] | undefined {\n  if (input.charCodeAt(idx) === 64 /*'@'*/) {\n    const directives: ast.DirectiveNode[] = [];\n    let _name: string | undefined;\n    do {\n      idx++;\n      if ((_name = advance(nameRe)) == null) throw error('Directive');\n      ignored();\n      directives.push({\n        kind: 'Directive' as Kind.DIRECTIVE,\n        name: { kind: 'Name' as Kind.NAME, value: _name },\n        arguments: arguments_(constant),\n      });\n    } while (input.charCodeAt(idx) === 64 /*'@'*/);\n    return directives;\n  }\n}\n\nfunction type(): ast.TypeNode {\n  let match: string | undefined;\n  let lists = 0;\n  while (input.charCodeAt(idx) === 91 /*'['*/) {\n    lists++;\n    idx++;\n    ignored();\n  }\n  if ((match = advance(nameRe)) == null) throw error('NamedType');\n  ignored();\n  let type: ast.TypeNode = {\n    kind: 'NamedType' as Kind.NAMED_TYPE,\n    name: { kind: 'Name' as Kind.NAME, value: match },\n  };\n  do {\n    if (input.charCodeAt(idx) === 33 /*'!'*/) {\n      idx++;\n      ignored();\n      type = {\n        kind: 'NonNullType' as Kind.NON_NULL_TYPE,\n        type: type as ast.NamedTypeNode | ast.ListTypeNode,\n      } satisfies ast.NonNullTypeNode;\n    }\n    if (lists) {\n      if (input.charCodeAt(idx++) !== 93 /*']'*/) throw error('NamedType');\n      ignored();\n      type = {\n        kind: 'ListType' as Kind.LIST_TYPE,\n        type: type as ast.NamedTypeNode | ast.ListTypeNode,\n      } satisfies ast.ListTypeNode;\n    }\n  } while (lists--);\n  return type;\n}\n\n// NOTE: This should be compressed by our build step\n// This merges the two possible selection parsing branches into one regular expression\nconst selectionRe = new RegExp(\n  '(?:' +\n    // fragment spreads (FragmentSpread or InlineFragment nodes)\n    '(\\\\.{3})|' +\n    // field aliases or names (FieldNode)\n    '(' +\n    nameRe.source +\n    '))',\n  'y'\n);\n\n// NOTE: Each of the groups above end up in the RegExpExecArray at the indices 1&2\nconst enum SelectionGroup {\n  Spread = 1,\n  Name,\n}\n\ntype SelectionExec = RegExpExecArray & {\n  [Prop in SelectionGroup]: string | undefined;\n};\n\nfunction selectionSet(): ast.SelectionSetNode {\n  const selections: ast.SelectionNode[] = [];\n  let match: string | undefined;\n  let exec: SelectionExec | null;\n  do {\n    selectionRe.lastIndex = idx;\n    if ((exec = selectionRe.exec(input) as SelectionExec) != null) {\n      idx = selectionRe.lastIndex;\n      if (exec[SelectionGroup.Spread] != null) {\n        ignored();\n        let match = advance(nameRe);\n        if (match != null && match !== 'on') {\n          // A simple `...Name` spread with optional directives\n          ignored();\n          selections.push({\n            kind: 'FragmentSpread' as Kind.FRAGMENT_SPREAD,\n            name: { kind: 'Name' as Kind.NAME, value: match },\n            directives: directives(false),\n          });\n        } else {\n          ignored();\n          if (match === 'on') {\n            // An inline `... on Name` spread; if this doesn't match, the type condition has been omitted\n            if ((match = advance(nameRe)) == null) throw error('NamedType');\n            ignored();\n          }\n          const _directives = directives(false);\n          if (input.charCodeAt(idx++) !== 123 /*'{'*/) throw error('InlineFragment');\n          ignored();\n          selections.push({\n            kind: 'InlineFragment' as Kind.INLINE_FRAGMENT,\n            typeCondition: match\n              ? {\n                  kind: 'NamedType' as Kind.NAMED_TYPE,\n                  name: { kind: 'Name' as Kind.NAME, value: match },\n                }\n              : undefined,\n            directives: _directives,\n            selectionSet: selectionSet(),\n          });\n        }\n      } else if ((match = exec[SelectionGroup.Name]) != null) {\n        let _alias: string | undefined;\n        ignored();\n        // Parse the optional alias, by reassigning and then getting the name\n        if (input.charCodeAt(idx) === 58 /*':'*/) {\n          idx++;\n          ignored();\n          _alias = match;\n          if ((match = advance(nameRe)) == null) throw error('Field');\n          ignored();\n        }\n        const _arguments = arguments_(false);\n        ignored();\n        const _directives = directives(false);\n        let _selectionSet: ast.SelectionSetNode | undefined;\n        if (input.charCodeAt(idx) === 123 /*'{'*/) {\n          idx++;\n          ignored();\n          _selectionSet = selectionSet();\n        }\n        selections.push({\n          kind: 'Field' as Kind.FIELD,\n          alias: _alias ? { kind: 'Name' as Kind.NAME, value: _alias } : undefined,\n          name: { kind: 'Name' as Kind.NAME, value: match },\n          arguments: _arguments,\n          directives: _directives,\n          selectionSet: _selectionSet,\n        });\n      }\n    } else {\n      throw error('SelectionSet');\n    }\n  } while (input.charCodeAt(idx) !== 125 /*'}'*/);\n  idx++;\n  ignored();\n  return {\n    kind: 'SelectionSet' as Kind.SELECTION_SET,\n    selections,\n  };\n}\n\nfunction variableDefinitions(): ast.VariableDefinitionNode[] | undefined {\n  ignored();\n  if (input.charCodeAt(idx) === 40 /*'('*/) {\n    const vars: ast.VariableDefinitionNode[] = [];\n    idx++;\n    ignored();\n    let _name: string | undefined;\n    do {\n      if (input.charCodeAt(idx++) !== 36 /*'$'*/) throw error('Variable');\n      if ((_name = advance(nameRe)) == null) throw error('Variable');\n      ignored();\n      if (input.charCodeAt(idx++) !== 58 /*':'*/) throw error('VariableDefinition');\n      ignored();\n      const _type = type();\n      let _defaultValue: ast.ConstValueNode | undefined;\n      if (input.charCodeAt(idx) === 61 /*'='*/) {\n        idx++;\n        ignored();\n        _defaultValue = value(true);\n      }\n      ignored();\n      vars.push({\n        kind: 'VariableDefinition' as Kind.VARIABLE_DEFINITION,\n        variable: {\n          kind: 'Variable' as Kind.VARIABLE,\n          name: { kind: 'Name' as Kind.NAME, value: _name },\n        },\n        type: _type,\n        defaultValue: _defaultValue,\n        directives: directives(true),\n      });\n    } while (input.charCodeAt(idx) !== 41 /*')'*/);\n    idx++;\n    ignored();\n    return vars;\n  }\n}\n\nfunction fragmentDefinition(): ast.FragmentDefinitionNode {\n  let _name: string | undefined;\n  let _condition: string | undefined;\n  if ((_name = advance(nameRe)) == null) throw error('FragmentDefinition');\n  ignored();\n  if (advance(nameRe) !== 'on') throw error('FragmentDefinition');\n  ignored();\n  if ((_condition = advance(nameRe)) == null) throw error('FragmentDefinition');\n  ignored();\n  const _directives = directives(false);\n  if (input.charCodeAt(idx++) !== 123 /*'{'*/) throw error('FragmentDefinition');\n  ignored();\n  return {\n    kind: 'FragmentDefinition' as Kind.FRAGMENT_DEFINITION,\n    name: { kind: 'Name' as Kind.NAME, value: _name },\n    typeCondition: {\n      kind: 'NamedType' as Kind.NAMED_TYPE,\n      name: { kind: 'Name' as Kind.NAME, value: _condition },\n    },\n    directives: _directives,\n    selectionSet: selectionSet(),\n  };\n}\n\nconst definitionRe = /(?:query|mutation|subscription|fragment)/y;\n\nfunction operationDefinition(\n  operation: OperationTypeNode | undefined\n): ast.OperationDefinitionNode | undefined {\n  let _name: string | undefined;\n  let _variableDefinitions: ast.VariableDefinitionNode[] | undefined;\n  let _directives: ast.DirectiveNode[] | undefined;\n  if (operation) {\n    ignored();\n    _name = advance(nameRe);\n    _variableDefinitions = variableDefinitions();\n    _directives = directives(false);\n  }\n  if (input.charCodeAt(idx) === 123 /*'{'*/) {\n    idx++;\n    ignored();\n    return {\n      kind: 'OperationDefinition' as Kind.OPERATION_DEFINITION,\n      operation: operation || ('query' as OperationTypeNode.QUERY),\n      name: _name ? { kind: 'Name' as Kind.NAME, value: _name } : undefined,\n      variableDefinitions: _variableDefinitions,\n      directives: _directives,\n      selectionSet: selectionSet(),\n    };\n  }\n}\n\nfunction document(): ast.DocumentNode {\n  let match: string | undefined;\n  let definition: ast.OperationDefinitionNode | undefined;\n  ignored();\n  const definitions: ast.ExecutableDefinitionNode[] = [];\n  do {\n    if ((match = advance(definitionRe)) === 'fragment') {\n      ignored();\n      definitions.push(fragmentDefinition());\n    } else if ((definition = operationDefinition(match as OperationTypeNode)) != null) {\n      definitions.push(definition);\n    } else {\n      throw error('Document');\n    }\n  } while (idx < input.length);\n  return {\n    kind: 'Document' as Kind.DOCUMENT,\n    definitions,\n  };\n}\n\ntype ParseOptions = {\n  [option: string]: any;\n};\n\nexport function parse(\n  string: string | Source,\n  _options?: ParseOptions | undefined\n): ast.DocumentNode {\n  input = typeof string.body === 'string' ? string.body : string;\n  idx = 0;\n  return document();\n}\n\nexport function parseValue(\n  string: string | Source,\n  _options?: ParseOptions | undefined\n): ast.ValueNode {\n  input = typeof string.body === 'string' ? string.body : string;\n  idx = 0;\n  ignored();\n  return value(false);\n}\n\nexport function parseType(\n  string: string | Source,\n  _options?: ParseOptions | undefined\n): ast.TypeNode {\n  input = typeof string.body === 'string' ? string.body : string;\n  idx = 0;\n  return type();\n}\n","import * as React from 'react';\nimport { pipe, onPush, filter, toPromise, take } from 'wonka';\n\nimport type {\n  AnyVariables,\n  DocumentInput,\n  OperationResult,\n  OperationContext,\n  CombinedError,\n  Operation,\n} from '@urql/core';\nimport { createRequest } from '@urql/core';\n\nimport { useClient } from '../context';\nimport { deferDispatch, initialState } from './state';\n\n/** State of the last mutation executed by your {@link useMutation} hook.\n *\n * @remarks\n * `UseMutationState` is returned (in a tuple) by {@link useMutation} and\n * gives you the {@link OperationResult} of the last mutation executed\n * with {@link UseMutationExecute}.\n *\n * Even if the mutation document passed to {@link useMutation} changes,\n * the state isnt reset, so you can keep displaying the previous result.\n */\nexport interface UseMutationState<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables,\n> {\n  /** Indicates whether `useMutation` is currently executing a mutation. */\n  fetching: boolean;\n  /** Indicates that the mutation result is not fresh.\n   *\n   * @remarks\n   * The `stale` flag is set to `true` when a new result for the mutation\n   * is expected.\n   * This is mostly unused for mutations and will rarely affect you, and\n   * is more relevant for queries.\n   *\n   * @see {@link OperationResult.stale} for the source of this value.\n   */\n  stale: boolean;\n  /** The {@link OperationResult.data} for the executed mutation. */\n  data?: Data;\n  /** The {@link OperationResult.error} for the executed mutation. */\n  error?: CombinedError;\n  /** The {@link OperationResult.extensions} for the executed mutation. */\n  extensions?: Record<string, any>;\n  /** The {@link Operation} that the current state is for.\n   *\n   * @remarks\n   * This is the mutation {@link Operation} that has last been executed.\n   * When {@link UseQueryState.fetching} is `true`, this is the\n   * last `Operation` that the current state was for.\n   */\n  operation?: Operation<Data, Variables>;\n}\n\n/** Triggers {@link useMutation} to execute its GraphQL mutation operation.\n *\n * @param variables - variables using which the mutation will be executed.\n * @param context - optionally, context options that will be merged with the hook's\n * {@link UseQueryArgs.context} options and the `Client`s options.\n * @returns the {@link OperationResult} of the mutation.\n *\n * @remarks\n * When called, {@link useMutation} will start the GraphQL mutation\n * it currently holds and use the `variables` passed to it.\n *\n * Once the mutation response comes back from the API, its\n * returned promise will resolve to the mutations {@link OperationResult}\n * and the {@link UseMutationState} will be updated with the result.\n *\n * @example\n * ```ts\n * const [result, executeMutation] = useMutation(UpdateTodo);\n * const start = async ({ id, title }) => {\n *   const result = await executeMutation({ id, title });\n * };\n */\nexport type UseMutationExecute<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables,\n> = (\n  variables: Variables,\n  context?: Partial<OperationContext>\n) => Promise<OperationResult<Data, Variables>>;\n\n/** Result tuple returned by the {@link useMutation} hook.\n *\n * @remarks\n * Similarly to a `useState` hooks return value,\n * the first element is the {@link useMutation}s state, updated\n * as mutations are executed with the second value, which is\n * used to start mutations and is a {@link UseMutationExecute}\n * function.\n */\nexport type UseMutationResponse<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables,\n> = [UseMutationState<Data, Variables>, UseMutationExecute<Data, Variables>];\n\n/** Hook to create a GraphQL mutation, run by passing variables to the returned execute function.\n *\n * @param query - a GraphQL mutation document which `useMutation` will execute.\n * @returns a {@link UseMutationResponse} tuple of a {@link UseMutationState} result,\n * and an execute function to start the mutation.\n *\n * @remarks\n * `useMutation` allows GraphQL mutations to be defined and keeps its state\n * after the mutation is started with the returned execute function.\n *\n * Given a GraphQL mutation document it returns state to keep track of the\n * mutation state and a {@link UseMutationExecute} function, which accepts\n * variables for the mutation to be executed.\n * Once called, the mutation executes and the state will be updated with\n * the mutations result.\n *\n * @see {@link https://urql.dev/goto/urql/docs/basics/react-preact/#mutations} for `useMutation` docs.\n *\n * @example\n * ```ts\n * import { gql, useMutation } from 'urql';\n *\n * const UpdateTodo = gql`\n *   mutation ($id: ID!, $title: String!) {\n *     updateTodo(id: $id, title: $title) {\n *       id, title\n *     }\n *   }\n * `;\n *\n * const UpdateTodo = () => {\n *   const [result, executeMutation] = useMutation(UpdateTodo);\n *   const start = async ({ id, title }) => {\n *     const result = await executeMutation({ id, title });\n *   };\n *   // ...\n * };\n * ```\n */\nexport function useMutation<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables,\n>(query: DocumentInput<Data, Variables>): UseMutationResponse<Data, Variables> {\n  const isMounted = React.useRef(true);\n  const client = useClient();\n\n  const [state, setState] =\n    React.useState<UseMutationState<Data, Variables>>(initialState);\n\n  const executeMutation = React.useCallback(\n    (variables: Variables, context?: Partial<OperationContext>) => {\n      deferDispatch(setState, { ...initialState, fetching: true });\n      return pipe(\n        client.executeMutation<Data, Variables>(\n          createRequest<Data, Variables>(query, variables),\n          context || {}\n        ),\n        onPush(result => {\n          if (isMounted.current) {\n            deferDispatch(setState, {\n              fetching: false,\n              stale: result.stale,\n              data: result.data,\n              error: result.error,\n              extensions: result.extensions,\n              operation: result.operation,\n            });\n          }\n        }),\n        filter(result => !result.hasNext),\n        take(1),\n        toPromise\n      );\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [client, query, setState]\n  );\n\n  React.useEffect(() => {\n    isMounted.current = true;\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n\n  return [state, executeMutation];\n}\n","/** Used to recursively mark `__typename` fields in data as non-enumerable.\n *\n * @deprecated Not recommended over modelling inputs manually (See #3299)\n *\n * @remarks\n * This utility can be used to recursively copy GraphQl response data and hide\n * all `__typename` fields present on it.\n *\n * Hint: Its not recommended to do this, unless it's absolutely necessary as\n * cloning and modifying all data of a response can be unnecessarily slow, when\n * a manual and more specific copy/mask is more efficient.\n *\n * @see {@link ClientOptions.maskTypename} for a description of how the `Client` uses this utility.\n */\nexport const maskTypename = (data: any, isRoot?: boolean): any => {\n  if (!data || typeof data !== 'object') {\n    return data;\n  } else if (Array.isArray(data)) {\n    return data.map(d => maskTypename(d));\n  } else if (\n    data &&\n    typeof data === 'object' &&\n    (isRoot || '__typename' in data)\n  ) {\n    const acc = {};\n    for (const key in data) {\n      if (key === '__typename') {\n        Object.defineProperty(acc, '__typename', {\n          enumerable: false,\n          value: data.__typename,\n        });\n      } else {\n        acc[key] = maskTypename(data[key]);\n      }\n    }\n    return acc;\n  } else {\n    return data;\n  }\n};\n","import * as React from 'react';\nimport type { AnyVariables, DocumentInput, GraphQLRequest } from '@urql/core';\nimport { createRequest } from '@urql/core';\n\n/** Creates a request from a query and variables but preserves reference equality if the key isn't changing\n * @internal\n */\nexport function useRequest<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables,\n>(\n  query: DocumentInput<Data, Variables>,\n  variables: Variables\n): GraphQLRequest<Data, Variables> {\n  const prev = React.useRef<undefined | GraphQLRequest<Data, Variables>>(\n    undefined\n  );\n\n  return React.useMemo(() => {\n    const request = createRequest<Data, Variables>(query, variables);\n    // We manually ensure reference equality if the key hasn't changed\n    if (prev.current !== undefined && prev.current.key === request.key) {\n      return prev.current;\n    } else {\n      prev.current = request;\n      return request;\n    }\n  }, [query, variables]);\n}\n","import type { Sink, Source } from 'wonka';\nimport { subscribe, take, filter, toPromise, pipe } from 'wonka';\nimport type { OperationResult, OperationResultSource } from '../types';\n\n/** Patches a `toPromise` method onto the `Source` passed to it.\n * @param source$ - the Wonka {@link Source} to patch.\n * @returns The passed `source$` with a patched `toPromise` method as a {@link PromisifiedSource}.\n * @internal\n */\nexport function withPromise<T extends OperationResult>(\n  _source$: Source<T>\n): OperationResultSource<T> {\n  const source$ = ((sink: Sink<T>) =>\n    _source$(sink)) as OperationResultSource<T>;\n  source$.toPromise = () =>\n    pipe(\n      source$,\n      filter(result => !result.stale && !result.hasNext),\n      take(1),\n      toPromise\n    );\n  source$.then = (onResolve, onReject) =>\n    source$.toPromise().then(onResolve, onReject);\n  source$.subscribe = onResult => subscribe(onResult)(source$);\n  return source$;\n}\n","import { Kind, parse, print } from '@0no-co/graphql.web';\nimport type { DocumentNode, DefinitionNode } from './graphql';\nimport type { HashValue } from './hash';\nimport { phash } from './hash';\nimport { stringifyVariables } from './variables';\n\nimport type {\n  DocumentInput,\n  TypedDocumentNode,\n  AnyVariables,\n  GraphQLRequest,\n  RequestExtensions,\n} from '../types';\n\n/** A `DocumentNode` annotated with its hashed key.\n * @internal\n */\nexport type KeyedDocumentNode = TypedDocumentNode & {\n  __key: HashValue;\n};\n\nconst SOURCE_NAME = 'gql';\nconst GRAPHQL_STRING_RE = /(\"{3}[\\s\\S]*\"{3}|\"(?:\\\\.|[^\"])*\")/g;\nconst REPLACE_CHAR_RE = /(?:#[^\\n\\r]+)?(?:[\\r\\n]+|$)/g;\n\nconst replaceOutsideStrings = (str: string, idx: number) =>\n  idx % 2 === 0 ? str.replace(REPLACE_CHAR_RE, '\\n') : str;\n\n/** Sanitizes a GraphQL document string by replacing comments and redundant newlines in it. */\nconst sanitizeDocument = (node: string): string =>\n  node.split(GRAPHQL_STRING_RE).map(replaceOutsideStrings).join('').trim();\n\nconst prints = new Map<DocumentNode | DefinitionNode, string>();\nconst docs = new Map<HashValue, KeyedDocumentNode>();\n\n/** A cached printing function for GraphQL documents.\n *\n * @param node - A string of a document or a {@link DocumentNode}\n * @returns A normalized printed string of the passed GraphQL document.\n *\n * @remarks\n * This function accepts a GraphQL query string or {@link DocumentNode},\n * then prints and sanitizes it. The sanitizer takes care of removing\n * comments, which otherwise alter the key of the document although the\n * document is otherwise equivalent to another.\n *\n * When a {@link DocumentNode} is passed to this function, it caches its\n * output by modifying the `loc.source.body` property on the GraphQL node.\n */\nexport const stringifyDocument = (\n  node: string | DefinitionNode | DocumentNode\n): string => {\n  let printed: string;\n  if (typeof node === 'string') {\n    printed = sanitizeDocument(node);\n  } else if (node.loc && docs.get((node as KeyedDocumentNode).__key) === node) {\n    printed = node.loc.source.body;\n  } else {\n    printed = prints.get(node) || sanitizeDocument(print(node));\n    prints.set(node, printed);\n  }\n\n  if (typeof node !== 'string' && !node.loc) {\n    (node as any).loc = {\n      start: 0,\n      end: printed.length,\n      source: {\n        body: printed,\n        name: SOURCE_NAME,\n        locationOffset: { line: 1, column: 1 },\n      },\n    };\n  }\n\n  return printed;\n};\n\n/** Computes the hash for a document's string using {@link stringifyDocument}'s output.\n *\n * @param node - A string of a document or a {@link DocumentNode}\n * @returns A {@link HashValue}\n *\n * @privateRemarks\n * This function adds the operation name of the document to the hash, since sometimes\n * a merged document with multiple operations may be used. Although `urql` requires a\n * `DocumentNode` to only contain a single operation, when the cached `loc.source.body`\n * of a `DocumentNode` is used, this string may still contain multiple operations and\n * the resulting hash should account for only one at a time.\n */\nconst hashDocument = (\n  node: string | DefinitionNode | DocumentNode\n): HashValue => {\n  let key = phash(stringifyDocument(node));\n  // Add the operation name to the produced hash\n  if ((node as DocumentNode).definitions) {\n    const operationName = getOperationName(node as DocumentNode);\n    if (operationName) key = phash(`\\n# ${operationName}`, key);\n  }\n  return key;\n};\n\n/** Returns a canonical version of the passed `DocumentNode` with an added hash key.\n *\n * @param node - A string of a document or a {@link DocumentNode}\n * @returns A {@link KeyedDocumentNode}\n *\n * @remarks\n * `urql` will always avoid unnecessary work, no matter whether a user passes `DocumentNode`s\n * or strings of GraphQL documents to its APIs.\n *\n * This function will return a canonical version of a {@link KeyedDocumentNode} no matter\n * which kind of input is passed, avoiding parsing or hashing of passed data as needed.\n */\nexport const keyDocument = (node: string | DocumentNode): KeyedDocumentNode => {\n  let key: HashValue;\n  let query: DocumentNode;\n  if (typeof node === 'string') {\n    key = hashDocument(node);\n    query = docs.get(key) || parse(node, { noLocation: true });\n  } else {\n    key = (node as KeyedDocumentNode).__key || hashDocument(node);\n    query = docs.get(key) || node;\n  }\n\n  // Add location information if it's missing\n  if (!query.loc) stringifyDocument(query);\n\n  (query as KeyedDocumentNode).__key = key;\n  docs.set(key, query as KeyedDocumentNode);\n  return query as KeyedDocumentNode;\n};\n\n/** Creates a `GraphQLRequest` from the passed parameters.\n *\n * @param q - A string of a document or a {@link DocumentNode}\n * @param variables - A variables object for the defined GraphQL operation.\n * @returns A {@link GraphQLRequest}\n *\n * @remarks\n * `createRequest` creates a {@link GraphQLRequest} from the passed parameters,\n * while replacing the document as needed with a canonical version of itself,\n * to avoid parsing, printing, or hashing the same input multiple times.\n *\n * If no variables are passed, canonically it'll default to an empty object,\n * which is removed from the resulting hash key.\n */\nexport const createRequest = <\n  Data = any,\n  Variables extends AnyVariables = AnyVariables,\n>(\n  _query: DocumentInput<Data, Variables>,\n  _variables: Variables,\n  extensions?: RequestExtensions | undefined\n): GraphQLRequest<Data, Variables> => {\n  const variables = _variables || ({} as Variables);\n  const query = keyDocument(_query);\n  const printedVars = stringifyVariables(variables);\n  let key = query.__key;\n  if (printedVars !== '{}') key = phash(printedVars, key);\n  return { key, query, variables, extensions };\n};\n\n/** Returns the name of the `DocumentNode`'s operation, if any.\n * @param query - A {@link DocumentNode}\n * @returns the operation's name contained within the document, or `undefined`\n */\nexport const getOperationName = (query: DocumentNode): string | undefined => {\n  for (const node of query.definitions) {\n    if (node.kind === Kind.OPERATION_DEFINITION) {\n      return node.name ? node.name.value : undefined;\n    }\n  }\n};\n\n/** Returns the type of the `DocumentNode`'s operation, if any.\n * @param query - A {@link DocumentNode}\n * @returns the operation's type contained within the document, or `undefined`\n */\nexport const getOperationType = (query: DocumentNode): string | undefined => {\n  for (const node of query.definitions) {\n    if (node.kind === Kind.OPERATION_DEFINITION) {\n      return node.operation;\n    }\n  }\n};\n","import { pipe, subscribe } from 'wonka';\nimport type { Client, OperationResult } from '@urql/core';\n\ntype CacheEntry = OperationResult | Promise<unknown> | undefined;\n\ninterface Cache {\n  get(key: number): CacheEntry;\n  set(key: number, value: CacheEntry): void;\n  dispose(key: number): void;\n}\n\ninterface ClientWithCache extends Client {\n  _react?: Cache;\n}\n\nexport const getCacheForClient = (client: Client): Cache => {\n  if (!(client as ClientWithCache)._react) {\n    const reclaim = new Set();\n    const map = new Map<number, CacheEntry>();\n\n    if (client.operations$ /* not available in mocks */) {\n      pipe(\n        client.operations$,\n        subscribe(operation => {\n          if (operation.kind === 'teardown' && reclaim.has(operation.key)) {\n            reclaim.delete(operation.key);\n            map.delete(operation.key);\n          }\n        })\n      );\n    }\n\n    (client as ClientWithCache)._react = {\n      get(key) {\n        return map.get(key);\n      },\n      set(key, value) {\n        reclaim.delete(key);\n        map.set(key, value);\n      },\n      dispose(key) {\n        reclaim.add(key);\n      },\n    };\n  }\n\n  return (client as ClientWithCache)._react!;\n};\n","import type {\n  AnyVariables,\n  GraphQLRequest,\n  Operation,\n  OperationContext,\n  OperationType,\n} from '../types';\n\n/** Creates a {@link Operation} from the given parameters.\n *\n * @param kind - The {@link OperationType} of GraphQL operation, i.e. `query`, `mutation`, or `subscription`.\n * @param request - The {@link GraphQLRequest} or {@link Operation} used as a template for the new `Operation`.\n * @param context - The {@link OperationContext} `context` data for the `Operation`.\n * @returns A new {@link Operation}.\n *\n * @remarks\n * This method is both used to create new {@link Operation | Operations} as well as copy and modify existing\n * operations. While its not required to use this function to copy an `Operation`, it is recommended, in case\n * additional dynamic logic is added to them in the future.\n *\n * Hint: When an {@link Operation} is passed to the `request` argument, the `context` argument does not have to be\n * a complete {@link OperationContext} and will instead be combined with passed {@link Operation.context}.\n *\n * @example\n * An example of copying an existing `Operation` to modify its `context`:\n *\n * ```ts\n * makeOperation(\n *   operation.kind,\n *   operation,\n *   { requestPolicy: 'cache-first' },\n * );\n * ```\n */\nfunction makeOperation<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables,\n>(\n  kind: OperationType,\n  request: GraphQLRequest<Data, Variables>,\n  context: OperationContext\n): Operation<Data, Variables>;\n\nfunction makeOperation<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables,\n>(\n  kind: OperationType,\n  request: Operation<Data, Variables>,\n  context?: Partial<OperationContext>\n): Operation<Data, Variables>;\n\nfunction makeOperation(kind, request, context) {\n  return {\n    ...request,\n    kind,\n    context: request.context\n      ? {\n          ...request.context,\n          ...context,\n        }\n      : context || request.context,\n  };\n}\n\nexport { makeOperation };\n\n/** Adds additional metadata to an `Operation`'s `context.meta` property while copying it.\n * @see {@link OperationDebugMeta} for more information on the {@link OperationContext.meta} property.\n */\nexport const addMetadata = (\n  operation: Operation,\n  meta: OperationContext['meta']\n) => {\n  return makeOperation(operation.kind, operation, {\n    meta: {\n      ...operation.context.meta,\n      ...meta,\n    },\n  });\n};\n","export * from './error';\nexport * from './request';\nexport * from './result';\nexport * from './variables';\nexport * from './collectTypenames';\nexport * from './formatDocument';\nexport * from './maskTypename';\nexport * from './streamUtils';\nexport * from './operation';\n\nexport const noop = () => {\n  /* noop */\n};\n","/* eslint-disable react-hooks/exhaustive-deps */\n\nimport type { Source } from 'wonka';\nimport { pipe, subscribe, onEnd, onPush, takeWhile } from 'wonka';\nimport * as React from 'react';\n\nimport type {\n  GraphQLRequestParams,\n  AnyVariables,\n  Client,\n  CombinedError,\n  OperationContext,\n  RequestPolicy,\n  OperationResult,\n  Operation,\n} from '@urql/core';\n\nimport { useClient } from '../context';\nimport { useRequest } from './useRequest';\nimport { getCacheForClient } from './cache';\n\nimport {\n  deferDispatch,\n  initialState,\n  computeNextState,\n  hasDepsChanged,\n} from './state';\n\n/** Input arguments for the {@link useQuery} hook.\n *\n * @param query - The GraphQL query that `useQuery` executes.\n * @param variables - The variables for the GraphQL query that `useQuery` executes.\n */\nexport type UseQueryArgs<\n  Variables extends AnyVariables = AnyVariables,\n  Data = any,\n> = {\n  /** Updates the {@link RequestPolicy} for the executed GraphQL query operation.\n   *\n   * @remarks\n   * `requestPolicy` modifies the {@link RequestPolicy} of the GraphQL query operation\n   * that `useQuery` executes, and indicates a caching strategy for cache exchanges.\n   *\n   * For example, when set to `'cache-and-network'`, {@link useQuery} will\n   * receive a cached result with `stale: true` and an API request will be\n   * sent in the background.\n   *\n   * @see {@link OperationContext.requestPolicy} for where this value is set.\n   */\n  requestPolicy?: RequestPolicy;\n  /** Updates the {@link OperationContext} for the executed GraphQL query operation.\n   *\n   * @remarks\n   * `context` may be passed to {@link useQuery}, to update the {@link OperationContext}\n   * of a query operation. This may be used to update the `context` that exchanges\n   * will receive for a single hook.\n   *\n   * Hint: This should be wrapped in a `useMemo` hook, to make sure that your\n   * component doesnt infinitely update.\n   *\n   * @example\n   * ```ts\n   * const [result, reexecute] = useQuery({\n   *   query,\n   *   context: useMemo(() => ({\n   *     additionalTypenames: ['Item'],\n   *   }), [])\n   * });\n   * ```\n   */\n  context?: Partial<OperationContext>;\n  /** Prevents {@link useQuery} from automatically executing GraphQL query operations.\n   *\n   * @remarks\n   * `pause` may be set to `true` to stop {@link useQuery} from executing\n   * automatically. The hook will stop receiving updates from the {@link Client}\n   * and wont execute the query operation, until either its set to `false`\n   * or the {@link UseQueryExecute} function is called.\n   *\n   * @see {@link https://urql.dev/goto/docs/basics/react-preact/#pausing-usequery} for\n   * documentation on the `pause` option.\n   */\n  pause?: boolean;\n} & GraphQLRequestParams<Data, Variables>;\n\n/** State of the current query, your {@link useQuery} hook is executing.\n *\n * @remarks\n * `UseQueryState` is returned (in a tuple) by {@link useQuery} and\n * gives you the updating {@link OperationResult} of GraphQL queries.\n *\n * Even when the query and variables passed to {@link useQuery} change,\n * this state preserves the prior state and sets the `fetching` flag to\n * `true`.\n * This allows you to display the previous state, while implementing\n * a separate loading indicator separately.\n */\nexport interface UseQueryState<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables,\n> {\n  /** Indicates whether `useQuery` is waiting for a new result.\n   *\n   * @remarks\n   * When `useQuery` is passed a new query and/or variables, it will\n   * start executing the new query operation and `fetching` is set to\n   * `true` until a result arrives.\n   *\n   * Hint: This is subtly different than whether the query is actually\n   * fetching, and doesnt indicate whether a query is being re-executed\n   * in the background. For this, see {@link UseQueryState.stale}.\n   */\n  fetching: boolean;\n  /** Indicates that the state is not fresh and a new result will follow.\n   *\n   * @remarks\n   * The `stale` flag is set to `true` when a new result for the query\n   * is expected and `useQuery` is waiting for it. This may indicate that\n   * a new request is being requested in the background.\n   *\n   * @see {@link OperationResult.stale} for the source of this value.\n   */\n  stale: boolean;\n  /** The {@link OperationResult.data} for the executed query. */\n  data?: Data;\n  /** The {@link OperationResult.error} for the executed query. */\n  error?: CombinedError;\n  /** The {@link OperationResult.extensions} for the executed query. */\n  extensions?: Record<string, any>;\n  /** The {@link Operation} that the current state is for.\n   *\n   * @remarks\n   * This is the {@link Operation} that is currently being executed.\n   * When {@link UseQueryState.fetching} is `true`, this is the\n   * last `Operation` that the current state was for.\n   */\n  operation?: Operation<Data, Variables>;\n}\n\n/** Triggers {@link useQuery} to execute a new GraphQL query operation.\n *\n * @param opts - optionally, context options that will be merged with the hook's\n * {@link UseQueryArgs.context} options and the `Client`s options.\n *\n * @remarks\n * When called, {@link useQuery} will re-execute the GraphQL query operation\n * it currently holds, even if {@link UseQueryArgs.pause} is set to `true`.\n *\n * This is useful for executing a paused query or re-executing a query\n * and get a new network result, by passing a new request policy.\n *\n * ```ts\n * const [result, reexecuteQuery] = useQuery({ query });\n *\n * const refresh = () => {\n *   // Re-execute the query with a network-only policy, skipping the cache\n *   reexecuteQuery({ requestPolicy: 'network-only' });\n * };\n * ```\n */\nexport type UseQueryExecute = (opts?: Partial<OperationContext>) => void;\n\n/** Result tuple returned by the {@link useQuery} hook.\n *\n * @remarks\n * Similarly to a `useState` hooks return value,\n * the first element is the {@link useQuery}s result and state,\n * a {@link UseQueryState} object,\n * and the second is used to imperatively re-execute the query\n * via a {@link UseQueryExecute} function.\n */\nexport type UseQueryResponse<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables,\n> = [UseQueryState<Data, Variables>, UseQueryExecute];\n\nconst isSuspense = (client: Client, context?: Partial<OperationContext>) =>\n  context && context.suspense !== undefined\n    ? !!context.suspense\n    : client.suspense;\n\n/** Hook to run a GraphQL query and get updated GraphQL results.\n *\n * @param args - a {@link UseQueryArgs} object, to pass a `query`, `variables`, and options.\n * @returns a {@link UseQueryResponse} tuple of a {@link UseQueryState} result, and re-execute function.\n *\n * @remarks\n * `useQuery` allows GraphQL queries to be defined and executed.\n * Given {@link UseQueryArgs.query}, it executes the GraphQL query with the\n * contexts {@link Client}.\n *\n * The returned result updates when the `Client` has new results\n * for the query, and changes when your input `args` change.\n *\n * Additionally, if the `suspense` option is enabled on the `Client`,\n * the `useQuery` hook will suspend instead of indicating that its\n * waiting for a result via {@link UseQueryState.fetching}.\n *\n * @see {@link https://urql.dev/goto/urql/docs/basics/react-preact/#queries} for `useQuery` docs.\n *\n * @example\n * ```ts\n * import { gql, useQuery } from 'urql';\n *\n * const TodosQuery = gql`\n *   query { todos { id, title } }\n * `;\n *\n * const Todos = () => {\n *   const [result, reexecuteQuery] = useQuery({\n *     query: TodosQuery,\n *     variables: {},\n *   });\n *   // ...\n * };\n * ```\n */\nexport function useQuery<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables,\n>(args: UseQueryArgs<Variables, Data>): UseQueryResponse<Data, Variables> {\n  const client = useClient();\n  const cache = getCacheForClient(client);\n  const suspense = isSuspense(client, args.context);\n  const request = useRequest(args.query, args.variables as Variables);\n\n  const source = React.useMemo(() => {\n    if (args.pause) return null;\n\n    const source = client.executeQuery(request, {\n      requestPolicy: args.requestPolicy,\n      ...args.context,\n    });\n\n    return suspense\n      ? pipe(\n          source,\n          onPush(result => {\n            cache.set(request.key, result);\n          })\n        )\n      : source;\n  }, [\n    cache,\n    client,\n    request,\n    suspense,\n    args.pause,\n    args.requestPolicy,\n    args.context,\n  ]);\n\n  const getSnapshot = React.useCallback(\n    (\n      source: Source<OperationResult<Data, Variables>> | null,\n      suspense: boolean\n    ): Partial<UseQueryState<Data, Variables>> => {\n      if (!source) return { fetching: false };\n\n      let result = cache.get(request.key);\n      if (!result) {\n        let resolve: (value: unknown) => void;\n\n        const subscription = pipe(\n          source,\n          takeWhile(() => (suspense && !resolve) || !result),\n          subscribe(_result => {\n            result = _result;\n            if (resolve) resolve(result);\n          })\n        );\n\n        if (result == null && suspense) {\n          const promise = new Promise(_resolve => {\n            resolve = _resolve;\n          });\n\n          cache.set(request.key, promise);\n          throw promise;\n        } else {\n          subscription.unsubscribe();\n        }\n      } else if (suspense && result != null && 'then' in result) {\n        throw result;\n      }\n\n      return (result as OperationResult<Data, Variables>) || { fetching: true };\n    },\n    [cache, request]\n  );\n\n  const deps = [\n    client,\n    request,\n    args.requestPolicy,\n    args.context,\n    args.pause,\n  ] as const;\n\n  const [state, setState] = React.useState(\n    () =>\n      [\n        source,\n        computeNextState(initialState, getSnapshot(source, suspense)),\n        deps,\n      ] as const\n  );\n\n  let currentResult = state[1];\n  if (source !== state[0] && hasDepsChanged(state[2], deps)) {\n    setState([\n      source,\n      (currentResult = computeNextState(\n        state[1],\n        getSnapshot(source, suspense)\n      )),\n      deps,\n    ]);\n  }\n\n  React.useEffect(() => {\n    const source = state[0];\n    const request = state[2][1];\n\n    let hasResult = false;\n\n    const updateResult = (result: Partial<UseQueryState<Data, Variables>>) => {\n      hasResult = true;\n      deferDispatch(setState, state => {\n        const nextResult = computeNextState(state[1], result);\n        return state[1] !== nextResult\n          ? [state[0], nextResult, state[2]]\n          : state;\n      });\n    };\n\n    if (source) {\n      const subscription = pipe(\n        source,\n        onEnd(() => {\n          updateResult({ fetching: false });\n        }),\n        subscribe(updateResult)\n      );\n\n      if (!hasResult) updateResult({ fetching: true });\n\n      return () => {\n        cache.dispose(request.key);\n        subscription.unsubscribe();\n      };\n    } else {\n      updateResult({ fetching: false });\n    }\n  }, [cache, state[0], state[2][1]]);\n\n  const executeQuery = React.useCallback(\n    (opts?: Partial<OperationContext>) => {\n      const context = {\n        requestPolicy: args.requestPolicy,\n        ...args.context,\n        ...opts,\n      };\n\n      deferDispatch(setState, state => {\n        const source = suspense\n          ? pipe(\n              client.executeQuery(request, context),\n              onPush(result => {\n                cache.set(request.key, result);\n              })\n            )\n          : client.executeQuery(request, context);\n        return [source, state[1], deps];\n      });\n    },\n    [\n      client,\n      cache,\n      request,\n      suspense,\n      args.requestPolicy,\n      args.context,\n      args.pause,\n    ]\n  );\n\n  return [currentResult, executeQuery];\n}\n","/* eslint-disable prefer-rest-params */\nimport { Kind } from '@0no-co/graphql.web';\nimport type { DocumentNode, DefinitionNode } from './utils/graphql';\nimport type { AnyVariables, TypedDocumentNode } from './types';\nimport { keyDocument, stringifyDocument } from './utils';\n\n/** A GraphQL parse function, which may be called as a tagged template literal, returning a parsed {@link DocumentNode}.\n *\n * @remarks\n * The `gql` tag or function is used to parse a GraphQL query document into a {@link DocumentNode}.\n *\n * When used as a tagged template, `gql` will automatically merge fragment definitions into the resulting\n * document and deduplicate them.\n *\n * It enforces that all fragments have a unique name. When fragments with different definitions share a name,\n * it will log a warning in development.\n *\n * Hint: Its recommended to use this `gql` function over other GraphQL parse functions, since it puts the parsed\n * results directly into `@urql/core`s internal caches and prevents further unnecessary work.\n *\n * @example\n * ```ts\n * const AuthorFragment = gql`\n *   fragment AuthorDisplayComponent on Author {\n *     id\n *     name\n *   }\n * `;\n *\n * const BookFragment = gql`\n *   fragment ListBookComponent on Book {\n *     id\n *     title\n *     author {\n *       ...AuthorDisplayComponent\n *     }\n *   }\n *\n *   ${AuthorFragment}\n * `;\n *\n * const BookQuery = gql`\n *   query Book($id: ID!) {\n *     book(id: $id) {\n *       ...BookFragment\n *     }\n *   }\n *\n *   ${BookFragment}\n * `;\n * ```\n */\nfunction gql<Data = any, Variables extends AnyVariables = AnyVariables>(\n  strings: TemplateStringsArray,\n  ...interpolations: Array<TypedDocumentNode | DocumentNode | string>\n): TypedDocumentNode<Data, Variables>;\n\nfunction gql<Data = any, Variables extends AnyVariables = AnyVariables>(\n  string: string\n): TypedDocumentNode<Data, Variables>;\n\nfunction gql(parts: string | TemplateStringsArray /* arguments */) {\n  const fragmentNames = new Map<string, string>();\n  const definitions: DefinitionNode[] = [];\n  const source: DocumentNode[] = [];\n\n  // Apply the entire tagged template body's definitions\n  let body: string = Array.isArray(parts) ? parts[0] : parts || '';\n  for (let i = 1; i < arguments.length; i++) {\n    const value = arguments[i];\n    if (value && value.definitions) {\n      source.push(value);\n    } else {\n      body += value;\n    }\n\n    body += arguments[0][i];\n  }\n\n  source.unshift(keyDocument(body));\n  for (const document of source) {\n    for (const definition of document.definitions) {\n      if (definition.kind === Kind.FRAGMENT_DEFINITION) {\n        const name = definition.name.value;\n        const value = stringifyDocument(definition);\n        // Fragments will be deduplicated according to this Map\n        if (!fragmentNames.has(name)) {\n          fragmentNames.set(name, value);\n          definitions.push(definition);\n        } else if (\n          process.env.NODE_ENV !== 'production' &&\n          fragmentNames.get(name) !== value\n        ) {\n          // Fragments with the same names is expected to have the same contents\n          console.warn(\n            '[WARNING: Duplicate Fragment] A fragment with name `' +\n              name +\n              '` already exists in this document.\\n' +\n              'While fragment names may not be unique across your source, each name must be unique per document.'\n          );\n        }\n      } else {\n        definitions.push(definition);\n      }\n    }\n  }\n\n  return keyDocument({\n    kind: Kind.DOCUMENT,\n    definitions,\n  });\n}\n\nexport { gql };\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { filter, map, merge, pipe, tap } from 'wonka';\n\nimport type { Client } from '../client';\nimport type { Exchange, Operation, OperationResult } from '../types';\n\nimport {\n  makeOperation,\n  addMetadata,\n  collectTypenames,\n  formatDocument,\n  makeResult,\n} from '../utils';\n\ntype ResultCache = Map<number, OperationResult>;\ntype OperationCache = Map<string, Set<number>>;\n\nconst shouldSkip = ({ kind }: Operation) =>\n  kind !== 'mutation' && kind !== 'query';\n\n/** Adds unique typenames to query (for invalidating cache entries) */\nexport const mapTypeNames = (operation: Operation): Operation => {\n  const query = formatDocument(operation.query);\n  if (query !== operation.query) {\n    const formattedOperation = makeOperation(operation.kind, operation);\n    formattedOperation.query = query;\n    return formattedOperation;\n  } else {\n    return operation;\n  }\n};\n\n/** Default document cache exchange.\n *\n * @remarks\n * The default document cache in `urql` avoids sending the same GraphQL request\n * multiple times by caching it using the {@link Operation.key}. It will invalidate\n * query results automatically whenever it sees a mutation responses with matching\n * `__typename`s in their responses.\n *\n * The document cache will get the introspected `__typename` fields by modifying\n * your GraphQL operation documents using the {@link formatDocument} utility.\n *\n * This automatic invalidation strategy can fail if your query or mutation dont\n * contain matching typenames, for instance, because the query contained an\n * empty list.\n * You can manually add hints for this exchange by specifying a list of\n * {@link OperationContext.additionalTypenames} for queries and mutations that\n * should invalidate one another.\n *\n * @see {@link https://urql.dev/goto/docs/basics/document-caching} for more information on this cache.\n */\nexport const cacheExchange: Exchange = ({ forward, client, dispatchDebug }) => {\n  const resultCache: ResultCache = new Map();\n  const operationCache: OperationCache = new Map();\n\n  const isOperationCached = (operation: Operation) =>\n    operation.kind === 'query' &&\n    operation.context.requestPolicy !== 'network-only' &&\n    (operation.context.requestPolicy === 'cache-only' ||\n      resultCache.has(operation.key));\n\n  return ops$ => {\n    const cachedOps$ = pipe(\n      ops$,\n      filter(op => !shouldSkip(op) && isOperationCached(op)),\n      map(operation => {\n        const cachedResult = resultCache.get(operation.key);\n\n        dispatchDebug({\n          operation,\n          ...(cachedResult\n            ? {\n                type: 'cacheHit',\n                message: 'The result was successfully retried from the cache',\n              }\n            : {\n                type: 'cacheMiss',\n                message: 'The result could not be retrieved from the cache',\n              }),\n        });\n\n        let result: OperationResult =\n          cachedResult ||\n          makeResult(operation, {\n            data: null,\n          });\n\n        result = {\n          ...result,\n          operation: addMetadata(operation, {\n            cacheOutcome: cachedResult ? 'hit' : 'miss',\n          }),\n        };\n\n        if (operation.context.requestPolicy === 'cache-and-network') {\n          result.stale = true;\n          reexecuteOperation(client, operation);\n        }\n\n        return result;\n      })\n    );\n\n    const forwardedOps$ = pipe(\n      merge([\n        pipe(\n          ops$,\n          filter(op => !shouldSkip(op) && !isOperationCached(op)),\n          map(mapTypeNames)\n        ),\n        pipe(\n          ops$,\n          filter(op => shouldSkip(op))\n        ),\n      ]),\n      map(op => addMetadata(op, { cacheOutcome: 'miss' })),\n      filter(\n        op => op.kind !== 'query' || op.context.requestPolicy !== 'cache-only'\n      ),\n      forward,\n      tap(response => {\n        let { operation } = response;\n        if (!operation) return;\n\n        let typenames = operation.context.additionalTypenames || [];\n        // NOTE: For now, we only respect `additionalTypenames` from subscriptions to\n        // avoid unexpected breaking changes\n        // We'd expect live queries or other update mechanisms to be more suitable rather\n        // than using subscriptions as signals to reexecute queries. However, if theyre\n        // just used as signals, its intuitive to hook them up using `additionalTypenames`\n        if (response.operation.kind !== 'subscription') {\n          typenames = collectTypenames(response.data).concat(typenames);\n        }\n\n        // Invalidates the cache given a mutation's response\n        if (\n          response.operation.kind === 'mutation' ||\n          response.operation.kind === 'subscription'\n        ) {\n          const pendingOperations = new Set<number>();\n\n          dispatchDebug({\n            type: 'cacheInvalidation',\n            message: `The following typenames have been invalidated: ${typenames}`,\n            operation,\n            data: { typenames, response },\n          });\n\n          for (let i = 0; i < typenames.length; i++) {\n            const typeName = typenames[i];\n            let operations = operationCache.get(typeName);\n            if (!operations)\n              operationCache.set(typeName, (operations = new Set()));\n            for (const key of operations.values()) pendingOperations.add(key);\n            operations.clear();\n          }\n\n          for (const key of pendingOperations.values()) {\n            if (resultCache.has(key)) {\n              operation = (resultCache.get(key) as OperationResult).operation;\n              resultCache.delete(key);\n              reexecuteOperation(client, operation);\n            }\n          }\n        } else if (operation.kind === 'query' && response.data) {\n          resultCache.set(operation.key, response);\n          for (let i = 0; i < typenames.length; i++) {\n            const typeName = typenames[i];\n            let operations = operationCache.get(typeName);\n            if (!operations)\n              operationCache.set(typeName, (operations = new Set()));\n            operations.add(operation.key);\n          }\n        }\n      })\n    );\n\n    return merge([cachedOps$, forwardedOps$]);\n  };\n};\n\n/** Reexecutes an `Operation` with the `network-only` request policy.\n * @internal\n */\nexport const reexecuteOperation = (client: Client, operation: Operation) => {\n  return client.reexecuteOperation(\n    makeOperation(operation.kind, operation, {\n      requestPolicy: 'network-only',\n    })\n  );\n};\n","import type {\n  ExecutionResult,\n  Operation,\n  OperationResult,\n  IncrementalPayload,\n} from '../types';\nimport { CombinedError } from './error';\n\n/** Converts the `ExecutionResult` received for a given `Operation` to an `OperationResult`.\n *\n * @param operation - The {@link Operation} for which the APIs result is for.\n * @param result - The GraphQL APIs {@link ExecutionResult}.\n * @param response - Optionally, a raw object representing the APIs result (Typically a {@link Response}).\n * @returns An {@link OperationResult}.\n *\n * @remarks\n * This utility can be used to create {@link OperationResult | OperationResults} in the shape\n * that `urql` expects and defines, and should be used rather than creating the results manually.\n *\n * @throws\n * If no data, or errors are contained within the result, or the result is instead an incremental\n * response containing a `path` property, a No Content error is thrown.\n *\n * @see {@link ExecutionResult} for the type definition of GraphQL API results.\n */\nexport const makeResult = (\n  operation: Operation,\n  result: ExecutionResult,\n  response?: any\n): OperationResult => {\n  if (\n    !('data' in result) &&\n    (!('errors' in result) || !Array.isArray(result.errors))\n  ) {\n    throw new Error('No Content');\n  }\n\n  const defaultHasNext = operation.kind === 'subscription';\n  return {\n    operation,\n    data: result.data,\n    error: Array.isArray(result.errors)\n      ? new CombinedError({\n          graphQLErrors: result.errors,\n          response,\n        })\n      : undefined,\n    extensions: result.extensions ? { ...result.extensions } : undefined,\n    hasNext: result.hasNext == null ? defaultHasNext : result.hasNext,\n    stale: false,\n  };\n};\n\nconst deepMerge = (target: any, source: any) => {\n  if (typeof target === 'object' && target != null) {\n    if (\n      !target.constructor ||\n      target.constructor === Object ||\n      Array.isArray(target)\n    ) {\n      target = Array.isArray(target) ? [...target] : { ...target };\n      for (const key of Object.keys(source))\n        target[key] = deepMerge(target[key], source[key]);\n      return target;\n    }\n  }\n  return source;\n};\n\n/** Merges an incrementally delivered `ExecutionResult` into a previous `OperationResult`.\n *\n * @param prevResult - The {@link OperationResult} that preceded this result.\n * @param path - The GraphQL APIs {@link ExecutionResult} that should be patching the `prevResult`.\n * @param response - Optionally, a raw object representing the APIs result (Typically a {@link Response}).\n * @returns A new {@link OperationResult} patched with the incremental result.\n *\n * @remarks\n * This utility should be used to merge subsequent {@link ExecutionResult | ExecutionResults} of\n * incremental responses into a prior {@link OperationResult}.\n *\n * When directives like `@defer`, `@stream`, and `@live` are used, GraphQL may deliver new\n * results that modify previous results. In these cases, it'll set a `path` property to modify\n * the result it sent last. This utility is built to handle these cases and merge these payloads\n * into existing {@link OperationResult | OperationResults}.\n *\n * @see {@link ExecutionResult} for the type definition of GraphQL API results.\n */\nexport const mergeResultPatch = (\n  prevResult: OperationResult,\n  nextResult: ExecutionResult,\n  response?: any,\n  pending?: ExecutionResult['pending']\n): OperationResult => {\n  let errors = prevResult.error ? prevResult.error.graphQLErrors : [];\n  let hasExtensions =\n    !!prevResult.extensions || !!(nextResult.payload || nextResult).extensions;\n  const extensions = {\n    ...prevResult.extensions,\n    ...(nextResult.payload || nextResult).extensions,\n  };\n\n  let incremental = nextResult.incremental;\n\n  // NOTE: We handle the old version of the incremental delivery payloads as well\n  if ('path' in nextResult) {\n    incremental = [nextResult as IncrementalPayload];\n  }\n\n  const withData = { data: prevResult.data };\n  if (incremental) {\n    for (const patch of incremental) {\n      if (Array.isArray(patch.errors)) {\n        errors.push(...(patch.errors as any));\n      }\n\n      if (patch.extensions) {\n        Object.assign(extensions, patch.extensions);\n        hasExtensions = true;\n      }\n\n      let prop: string | number = 'data';\n      let part: Record<string, any> | Array<any> = withData;\n      let path: readonly (string | number)[] = [];\n      if (patch.path) {\n        path = patch.path;\n      } else if (pending) {\n        const res = pending.find(pendingRes => pendingRes.id === patch.id);\n        if (patch.subPath) {\n          path = [...res!.path, ...patch.subPath];\n        } else {\n          path = res!.path;\n        }\n      }\n\n      for (let i = 0, l = path.length; i < l; prop = path[i++]) {\n        part = part[prop] = Array.isArray(part[prop])\n          ? [...part[prop]]\n          : { ...part[prop] };\n      }\n\n      if (patch.items) {\n        const startIndex = +prop >= 0 ? (prop as number) : 0;\n        for (let i = 0, l = patch.items.length; i < l; i++)\n          part[startIndex + i] = deepMerge(\n            part[startIndex + i],\n            patch.items[i]\n          );\n      } else if (patch.data !== undefined) {\n        part[prop] = deepMerge(part[prop], patch.data);\n      }\n    }\n  } else {\n    withData.data = (nextResult.payload || nextResult).data || prevResult.data;\n    errors =\n      (nextResult.errors as any[]) ||\n      (nextResult.payload && nextResult.payload.errors) ||\n      errors;\n  }\n\n  return {\n    operation: prevResult.operation,\n    data: withData.data,\n    error: errors.length\n      ? new CombinedError({ graphQLErrors: errors, response })\n      : undefined,\n    extensions: hasExtensions ? extensions : undefined,\n    hasNext:\n      nextResult.hasNext != null ? nextResult.hasNext : prevResult.hasNext,\n    stale: false,\n  };\n};\n\n/** Creates an `OperationResult` containing a network error for requests that encountered unexpected errors.\n *\n * @param operation - The {@link Operation} for which the APIs result is for.\n * @param error - The network-like error that prevented an API result from being delivered.\n * @param response - Optionally, a raw object representing the APIs result (Typically a {@link Response}).\n * @returns An {@link OperationResult} containing only a {@link CombinedError}.\n *\n * @remarks\n * This utility can be used to create {@link OperationResult | OperationResults} in the shape\n * that `urql` expects and defines, and should be used rather than creating the results manually.\n * This function should be used for when the {@link CombinedError.networkError} property is\n * populated and no GraphQL execution actually occurred.\n */\nexport const makeErrorResult = (\n  operation: Operation,\n  error: Error,\n  response?: any\n): OperationResult => ({\n  operation,\n  data: undefined,\n  error: new CombinedError({\n    networkError: error,\n    response,\n  }),\n  extensions: undefined,\n  hasNext: false,\n  stale: false,\n});\n","/* eslint-disable react-hooks/exhaustive-deps */\n\nimport { pipe, subscribe, onEnd } from 'wonka';\nimport * as React from 'react';\n\nimport type {\n  GraphQLRequestParams,\n  AnyVariables,\n  CombinedError,\n  OperationContext,\n  Operation,\n} from '@urql/core';\n\nimport { useClient } from '../context';\nimport { useRequest } from './useRequest';\n\nimport {\n  deferDispatch,\n  initialState,\n  computeNextState,\n  hasDepsChanged,\n} from './state';\n\n/** Input arguments for the {@link useSubscription} hook.\n *\n * @param query - The GraphQL subscription document that `useSubscription` executes.\n * @param variables - The variables for the GraphQL subscription that `useSubscription` executes.\n */\nexport type UseSubscriptionArgs<\n  Variables extends AnyVariables = AnyVariables,\n  Data = any,\n> = {\n  /** Prevents {@link useSubscription} from automatically starting GraphQL subscriptions.\n   *\n   * @remarks\n   * `pause` may be set to `true` to stop {@link useSubscription} from starting its subscription\n   * automatically. The hook will stop receiving updates from the {@link Client}\n   * and wont start the subscription operation, until either its set to `false`\n   * or the {@link UseSubscriptionExecute} function is called.\n   */\n  pause?: boolean;\n  /** Updates the {@link OperationContext} for the executed GraphQL subscription operation.\n   *\n   * @remarks\n   * `context` may be passed to {@link useSubscription}, to update the {@link OperationContext}\n   * of a subscription operation. This may be used to update the `context` that exchanges\n   * will receive for a single hook.\n   *\n   * Hint: This should be wrapped in a `useMemo` hook, to make sure that your\n   * component doesnt infinitely update.\n   *\n   * @example\n   * ```ts\n   * const [result, reexecute] = useSubscription({\n   *   query,\n   *   context: useMemo(() => ({\n   *     additionalTypenames: ['Item'],\n   *   }), [])\n   * });\n   * ```\n   */\n  context?: Partial<OperationContext>;\n} & GraphQLRequestParams<Data, Variables>;\n\n/** Combines previous data with an incoming subscription results data.\n *\n * @remarks\n * A `SubscriptionHandler` may be passed to {@link useSubscription} to\n * aggregate subscription results into a combined {@link UseSubscriptionState.data}\n * value.\n *\n * This is useful when a subscription event delivers a single item, while\n * youd like to display a list of events.\n *\n * @example\n * ```ts\n * const NotificationsSubscription = gql`\n *   subscription { newNotification { id, text } }\n * `;\n *\n * const combineNotifications = (notifications = [], data) => {\n *   return [...notifications, data.newNotification];\n * };\n *\n * const [result, executeSubscription] = useSubscription(\n *   { query: NotificationsSubscription },\n *   combineNotifications,\n * );\n * ```\n */\nexport type SubscriptionHandler<T, R> = (prev: R | undefined, data: T) => R;\n\n/** State of the current subscription, your {@link useSubscription} hook is executing.\n *\n * @remarks\n * `UseSubscriptionState` is returned (in a tuple) by {@link useSubscription} and\n * gives you the updating {@link OperationResult} of GraphQL subscriptions.\n *\n * If a {@link SubscriptionHandler} has been passed to `useSubscription` then\n * {@link UseSubscriptionState.data} is instead the updated data as returned\n * by the handler, otherwise its the latest results data.\n *\n * Hint: Even when the query and variables passed to {@link useSubscription} change,\n * this state preserves the prior state.\n */\nexport interface UseSubscriptionState<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables,\n> {\n  /** Indicates whether `useSubscription`s subscription is active.\n   *\n   * @remarks\n   * When `useSubscription` starts a subscription, the `fetching` flag\n   * is set to `true` and will remain `true` until the subscription\n   * completes on the API, or the {@link UseSubscriptionArgs.pause}\n   * flag is set to `true`.\n   */\n  fetching: boolean;\n  /** Indicates that the subscription result is not fresh.\n   *\n   * @remarks\n   * This is mostly unused for subscriptions and will rarely affect you, and\n   * is more relevant for queries.\n   *\n   * @see {@link OperationResult.stale} for the source of this value.\n   */\n  stale: boolean;\n  /** The {@link OperationResult.data} for the executed subscription, or data returned by a handler.\n   *\n   * @remarks\n   * `data` will be set to the last {@link OperationResult.data} value\n   * received for the subscription.\n   *\n   * It will instead be set to the values that {@link SubscriptionHandler}\n   * returned, if a handler has been passed to {@link useSubscription}.\n   */\n  data?: Data;\n  /** The {@link OperationResult.error} for the executed subscription. */\n  error?: CombinedError;\n  /** The {@link OperationResult.extensions} for the executed mutation. */\n  extensions?: Record<string, any>;\n  /** The {@link Operation} that the current state is for.\n   *\n   * @remarks\n   * This is the subscription {@link Operation} that is currently active.\n   * When {@link UseSubscriptionState.fetching} is `true`, this is the\n   * last `Operation` that the current state was for.\n   */\n  operation?: Operation<Data, Variables>;\n}\n\n/** Triggers {@link useSubscription} to reexecute a GraphQL subscription operation.\n *\n * @param opts - optionally, context options that will be merged with the hook's\n * {@link UseSubscriptionArgs.context} options and the `Client`s options.\n *\n * @remarks\n * When called, {@link useSubscription} will restart the GraphQL subscription\n * operation it currently holds. If {@link UseSubscriptionArgs.pause} is set\n * to `true`, it will start executing the subscription.\n *\n * ```ts\n * const [result, executeSubscription] = useSubscription({\n *   query,\n *   pause: true,\n * });\n *\n * const start = () => {\n *   executeSubscription();\n * };\n * ```\n */\nexport type UseSubscriptionExecute = (opts?: Partial<OperationContext>) => void;\n\n/** Result tuple returned by the {@link useSubscription} hook.\n *\n * @remarks\n * Similarly to a `useState` hooks return value,\n * the first element is the {@link useSubscription}s state,\n * a {@link UseSubscriptionState} object,\n * and the second is used to imperatively re-execute or start the subscription\n * via a {@link UseMutationExecute} function.\n */\nexport type UseSubscriptionResponse<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables,\n> = [UseSubscriptionState<Data, Variables>, UseSubscriptionExecute];\n\n/** Hook to run a GraphQL subscription and get updated GraphQL results.\n *\n * @param args - a {@link UseSubscriptionArgs} object, to pass a `query`, `variables`, and options.\n * @param handler - optionally, a {@link SubscriptionHandler} function to combine multiple subscription results.\n * @returns a {@link UseSubscriptionResponse} tuple of a {@link UseSubscriptionState} result, and an execute function.\n *\n * @remarks\n * `useSubscription` allows GraphQL subscriptions to be defined and executed.\n * Given {@link UseSubscriptionArgs.query}, it executes the GraphQL subscription with the\n * contexts {@link Client}.\n *\n * The returned result updates when the `Client` has new results\n * for the subscription, and `data` is updated with the results data\n * or with the `data` that a `handler` returns.\n *\n * @example\n * ```ts\n * import { gql, useSubscription } from 'urql';\n *\n * const NotificationsSubscription = gql`\n *   subscription { newNotification { id, text } }\n * `;\n *\n * const combineNotifications = (notifications = [], data) => {\n *   return [...notifications, data.newNotification];\n * };\n *\n * const Notifications = () => {\n *   const [result, executeSubscription] = useSubscription(\n *     { query: NotificationsSubscription },\n *     combineNotifications,\n *   );\n *   // ...\n * };\n * ```\n */\nexport function useSubscription<\n  Data = any,\n  Result = Data,\n  Variables extends AnyVariables = AnyVariables,\n>(\n  args: UseSubscriptionArgs<Variables, Data>,\n  handler?: SubscriptionHandler<Data, Result>\n): UseSubscriptionResponse<Result, Variables> {\n  const client = useClient();\n  const request = useRequest(args.query, args.variables as Variables);\n\n  const handlerRef = React.useRef<\n    SubscriptionHandler<Data, Result> | undefined\n  >(handler);\n  handlerRef.current = handler;\n\n  const source = React.useMemo(\n    () =>\n      !args.pause ? client.executeSubscription(request, args.context) : null,\n    [client, request, args.pause, args.context]\n  );\n\n  const deps = [client, request, args.context, args.pause] as const;\n\n  const [state, setState] = React.useState(\n    () => [source, { ...initialState, fetching: !!source }, deps] as const\n  );\n\n  let currentResult = state[1];\n  if (source !== state[0] && hasDepsChanged(state[2], deps)) {\n    setState([\n      source,\n      (currentResult = computeNextState(state[1], { fetching: !!source })),\n      deps,\n    ]);\n  }\n\n  React.useEffect(() => {\n    const updateResult = (\n      result: Partial<UseSubscriptionState<Data, Variables>>\n    ) => {\n      deferDispatch(setState, state => {\n        const nextResult = computeNextState(state[1], result);\n        if (state[1] === nextResult) return state;\n        if (handlerRef.current && state[1].data !== nextResult.data) {\n          nextResult.data = handlerRef.current(\n            state[1].data,\n            nextResult.data!\n          ) as any;\n        }\n\n        return [state[0], nextResult as any, state[2]];\n      });\n    };\n\n    if (state[0]) {\n      return pipe(\n        state[0],\n        onEnd(() => {\n          updateResult({ fetching: !!source });\n        }),\n        subscribe(updateResult)\n      ).unsubscribe;\n    } else {\n      updateResult({ fetching: false });\n    }\n  }, [state[0]]);\n\n  // This is the imperative execute function passed to the user\n  const executeSubscription = React.useCallback(\n    (opts?: Partial<OperationContext>) => {\n      const source = client.executeSubscription(request, {\n        ...args.context,\n        ...opts,\n      });\n\n      deferDispatch(setState, state => [source, state[1], deps]);\n    },\n    [client, request, args.context, args.pause]\n  );\n\n  return [currentResult, executeSubscription];\n}\n","import type { GraphQLError } from '../utils/graphql';\nimport { pipe, filter, merge, map, tap } from 'wonka';\nimport type { Exchange, OperationResult, Operation } from '../types';\nimport { addMetadata, CombinedError } from '../utils';\nimport { reexecuteOperation, mapTypeNames } from './cache';\n\n/** A serialized version of an {@link OperationResult}.\n *\n * @remarks\n * All properties are serialized separately as JSON strings, except for the\n * {@link CombinedError} to speed up JS parsing speed, even if a result doesnt\n * end up being used.\n *\n * @internal\n */\nexport interface SerializedResult {\n  hasNext?: boolean;\n  /** JSON-serialized version of {@link OperationResult.data}. */\n  data?: string | undefined; // JSON string of data\n  /** JSON-serialized version of {@link OperationResult.extensions}. */\n  extensions?: string | undefined;\n  /** JSON version of {@link CombinedError}. */\n  error?: {\n    graphQLErrors: Array<Partial<GraphQLError> | string>;\n    networkError?: string;\n  };\n}\n\n/** A dictionary of {@link Operation.key} keys to serializable {@link SerializedResult} objects.\n *\n * @remarks\n * Its not recommended to modify the serialized data manually, however, multiple payloads of\n * this dictionary may safely be merged and combined.\n */\nexport interface SSRData {\n  [key: string]: SerializedResult;\n}\n\n/** Options for the `ssrExchange` allowing it to either operate on the server- or client-side. */\nexport interface SSRExchangeParams {\n  /** Indicates to the {@link SSRExchange} whether it's currently in server-side or client-side mode.\n   *\n   * @remarks\n   * Depending on this option, the {@link SSRExchange} will either capture or replay results.\n   * When `true`, its in client-side mode and results will be serialized. When `false`, itll\n   * use its deserialized data and replay results from it.\n   */\n  isClient?: boolean;\n  /** May be used on the client-side to pass the {@link SSRExchange} serialized data from the server-side.\n   *\n   * @remarks\n   * Alternatively, {@link SSRExchange.restoreData} may be called to imperatively add serialized data to\n   * the exchange.\n   *\n   * Hint: This method also works on the server-side to add to the initial serialized data, which enables\n   * you to combine multiple {@link SSRExchange} results, as needed.\n   */\n  initialState?: SSRData;\n  /** Forces a new API request to be sent in the background after replaying the deserialized result.\n   *\n   * @remarks\n   * Similarly to the `cache-and-network` {@link RequestPolicy}, this option tells the {@link SSRExchange}\n   * to send a new API request for the {@link Operation} after replaying a serialized result.\n   *\n   * Hint: This is useful when you're caching SSR results and need the client-side to update itself after\n   * rendering the initial serialized SSR results.\n   */\n  staleWhileRevalidate?: boolean;\n  /** Forces {@link OperationResult.extensions} to be serialized alongside the rest of a result.\n   *\n   * @remarks\n   * Entries in the `extension` object of a GraphQL result are often non-standard metdata, and many\n   * APIs use it for data that changes between every request. As such, the {@link SSRExchange} will\n   * not serialize this data by default, unless this flag is set.\n   */\n  includeExtensions?: boolean;\n}\n\n/** An `SSRExchange` either in server-side mode, serializing results, or client-side mode, deserializing and replaying results..\n *\n * @remarks\n * This same {@link Exchange} is used in your code both for the client-side and server-side as its universal\n * and can be put into either client-side or server-side mode using the {@link SSRExchangeParams.isClient} flag.\n *\n * In server-side mode, the `ssrExchange` will record results it sees from your API and provide them for you\n * to send to the client-side using the {@link SSRExchange.extractData} method.\n *\n * In client-side mode, the `ssrExchange` will use these serialized results, rehydrated either using\n * {@link SSRExchange.restoreData} or {@link SSRexchangeParams.initialState}, to replay results the\n * server-side has seen and sent before.\n *\n * Each serialized result will only be replayed once, as its assumed that your cache exchange will have the\n * results cached afterwards.\n */\nexport interface SSRExchange extends Exchange {\n  /** Client-side method to add serialized results to the {@link SSRExchange}.\n   * @param data - {@link SSRData},\n   */\n  restoreData(data: SSRData): void;\n  /** Server-side method to get all serialized results the {@link SSRExchange} has captured.\n   * @returns an {@link SSRData} dictionary.\n   */\n  extractData(): SSRData;\n}\n\n/** Serialize an OperationResult to plain JSON */\nconst serializeResult = (\n  result: OperationResult,\n  includeExtensions: boolean\n): SerializedResult => {\n  const serialized: SerializedResult = {\n    data: JSON.stringify(result.data),\n    hasNext: result.hasNext,\n  };\n\n  if (result.data !== undefined) {\n    serialized.data = JSON.stringify(result.data);\n  }\n\n  if (includeExtensions && result.extensions !== undefined) {\n    serialized.extensions = JSON.stringify(result.extensions);\n  }\n\n  if (result.error) {\n    serialized.error = {\n      graphQLErrors: result.error.graphQLErrors.map(error => {\n        if (!error.path && !error.extensions) return error.message;\n\n        return {\n          message: error.message,\n          path: error.path,\n          extensions: error.extensions,\n        };\n      }),\n    };\n\n    if (result.error.networkError) {\n      serialized.error.networkError = '' + result.error.networkError;\n    }\n  }\n\n  return serialized;\n};\n\n/** Deserialize plain JSON to an OperationResult\n * @internal\n */\nconst deserializeResult = (\n  operation: Operation,\n  result: SerializedResult,\n  includeExtensions: boolean\n): OperationResult => ({\n  operation,\n  data: result.data ? JSON.parse(result.data) : undefined,\n  extensions:\n    includeExtensions && result.extensions\n      ? JSON.parse(result.extensions)\n      : undefined,\n  error: result.error\n    ? new CombinedError({\n        networkError: result.error.networkError\n          ? new Error(result.error.networkError)\n          : undefined,\n        graphQLErrors: result.error.graphQLErrors,\n      })\n    : undefined,\n  stale: false,\n  hasNext: !!result.hasNext,\n});\n\nconst revalidated = new Set<number>();\n\n/** Creates a server-side rendering `Exchange` that either captures responses on the server-side or replays them on the client-side.\n *\n * @param params - An {@link SSRExchangeParams} configuration object.\n * @returns the created {@link SSRExchange}\n *\n * @remarks\n * When dealing with server-side rendering, we essentially have two {@link Client | Clients} making requests,\n * the server-side client, and the client-side one. The `ssrExchange` helps implementing a tiny cache on both\n * sides that:\n *\n * - captures results on the server-side which it can serialize,\n * - replays results on the client-side that it deserialized from the server-side.\n *\n * Hint: The `ssrExchange` is basically an exchange that acts like a replacement for any fetch exchange\n * temporarily. As such, you should place it after your cache exchange but in front of any fetch exchange.\n */\nexport const ssrExchange = (params: SSRExchangeParams = {}): SSRExchange => {\n  const staleWhileRevalidate = !!params.staleWhileRevalidate;\n  const includeExtensions = !!params.includeExtensions;\n  const data: Record<string, SerializedResult | null> = {};\n\n  // On the client-side, we delete results from the cache as they're resolved\n  // this is delayed so that concurrent queries don't delete each other's data\n  const invalidateQueue: number[] = [];\n  const invalidate = (result: OperationResult) => {\n    invalidateQueue.push(result.operation.key);\n    if (invalidateQueue.length === 1) {\n      Promise.resolve().then(() => {\n        let key: number | void;\n        while ((key = invalidateQueue.shift())) {\n          data[key] = null;\n        }\n      });\n    }\n  };\n\n  // The SSR Exchange is a temporary cache that can populate results into data for suspense\n  // On the client it can be used to retrieve these temporary results from a rehydrated cache\n  const ssr: SSRExchange =\n    ({ client, forward }) =>\n    ops$ => {\n      // params.isClient tells us whether we're on the client-side\n      // By default we assume that we're on the client if suspense-mode is disabled\n      const isClient =\n        params && typeof params.isClient === 'boolean'\n          ? !!params.isClient\n          : !client.suspense;\n\n      let forwardedOps$ = pipe(\n        ops$,\n        filter(\n          operation =>\n            operation.kind === 'teardown' ||\n            !data[operation.key] ||\n            !!data[operation.key]!.hasNext ||\n            operation.context.requestPolicy === 'network-only'\n        ),\n        map(mapTypeNames),\n        forward\n      );\n\n      // NOTE: Since below we might delete the cached entry after accessing\n      // it once, cachedOps$ needs to be merged after forwardedOps$\n      let cachedOps$ = pipe(\n        ops$,\n        filter(\n          operation =>\n            operation.kind !== 'teardown' &&\n            !!data[operation.key] &&\n            operation.context.requestPolicy !== 'network-only'\n        ),\n        map(op => {\n          const serialized = data[op.key]!;\n          const cachedResult = deserializeResult(\n            op,\n            serialized,\n            includeExtensions\n          );\n\n          if (staleWhileRevalidate && !revalidated.has(op.key)) {\n            cachedResult.stale = true;\n            revalidated.add(op.key);\n            reexecuteOperation(client, op);\n          }\n\n          const result: OperationResult = {\n            ...cachedResult,\n            operation: addMetadata(op, {\n              cacheOutcome: 'hit',\n            }),\n          };\n          return result;\n        })\n      );\n\n      if (!isClient) {\n        // On the server we cache results in the cache as they're resolved\n        forwardedOps$ = pipe(\n          forwardedOps$,\n          tap((result: OperationResult) => {\n            const { operation } = result;\n            if (operation.kind !== 'mutation') {\n              const serialized = serializeResult(result, includeExtensions);\n              data[operation.key] = serialized;\n            }\n          })\n        );\n      } else {\n        // On the client we delete results from the cache as they're resolved\n        cachedOps$ = pipe(cachedOps$, tap(invalidate));\n      }\n\n      return merge([forwardedOps$, cachedOps$]);\n    };\n\n  ssr.restoreData = (restore: SSRData) => {\n    for (const key in restore) {\n      // We only restore data that hasn't been previously invalidated\n      if (data[key] !== null) {\n        data[key] = restore[key];\n      }\n    }\n  };\n\n  ssr.extractData = () => {\n    const result: SSRData = {};\n    for (const key in data) if (data[key] != null) result[key] = data[key]!;\n    return result;\n  };\n\n  if (params && params.initialState) {\n    ssr.restoreData(params.initialState);\n  }\n\n  return ssr;\n};\n","import type { ReactElement } from 'react';\nimport type { AnyVariables, DocumentInput } from '@urql/core';\n\nimport type { UseMutationState, UseMutationExecute } from '../hooks';\nimport { useMutation } from '../hooks';\n\n/** Props accepted by {@link Mutation}.\n *\n * @remarks\n * `MutationProps` are the props accepted by the {@link Mutation} component.\n *\n * The result, the {@link MutationState} object, will be passed to\n * a {@link MutationProps.children} function, passed as children\n * to the `Mutation` component.\n */\nexport interface MutationProps<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables,\n> {\n  /* The GraphQL mutation document that {@link useMutation} will execute. */\n  query: DocumentInput<Data, Variables>;\n  children(arg: MutationState<Data, Variables>): ReactElement<any>;\n}\n\n/** Object that {@link MutationProps.children} is called with.\n *\n * @remarks\n * This is an extented {@link UseMutationstate} with an added\n * {@link MutationState.executeMutation} method, which is usually\n * part of a tuple returned by {@link useMutation}.\n */\nexport interface MutationState<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables,\n> extends UseMutationState<Data, Variables> {\n  /** Alias to {@link useMutation}s `executeMutation` function. */\n  executeMutation: UseMutationExecute<Data, Variables>;\n}\n\n/** Component Wrapper around {@link useMutation} to run a GraphQL query.\n *\n * @remarks\n * `Mutation` is a component wrapper around the {@link useMutation} hook\n * that calls the {@link MutationProps.children} prop, as a function,\n * with the {@link MutationState} object.\n */\nexport function Mutation<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables,\n>(props: MutationProps<Data, Variables>): ReactElement<any> {\n  const mutation = useMutation<Data, Variables>(props.query);\n  return props.children({ ...mutation[0], executeMutation: mutation[1] });\n}\n","import type { ReactElement } from 'react';\nimport type { AnyVariables } from '@urql/core';\n\nimport type { UseQueryArgs, UseQueryState, UseQueryExecute } from '../hooks';\nimport { useQuery } from '../hooks';\n\n/** Props accepted by {@link Query}.\n *\n * @remarks\n * `QueryProps` are the props accepted by the {@link Query} component,\n * which is identical to {@link UseQueryArgs}.\n *\n * The result, the {@link QueryState} object, will be passed to\n * a {@link QueryProps.children} function, passed as children\n * to the `Query` component.\n */\nexport type QueryProps<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables,\n> = UseQueryArgs<Variables, Data> & {\n  children(arg: QueryState<Data, Variables>): ReactElement<any>;\n};\n\n/** Object that {@link QueryProps.children} is called with.\n *\n * @remarks\n * This is an extented {@link UseQueryState} with an added\n * {@link QueryState.executeQuery} method, which is usually\n * part of a tuple returned by {@link useQuery}.\n */\nexport interface QueryState<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables,\n> extends UseQueryState<Data, Variables> {\n  /** Alias to {@link useQuery}s `executeQuery` function. */\n  executeQuery: UseQueryExecute;\n}\n\n/** Component Wrapper around {@link useQuery} to run a GraphQL query.\n *\n * @remarks\n * `Query` is a component wrapper around the {@link useQuery} hook\n * that calls the {@link QueryProps.children} prop, as a function,\n * with the {@link QueryState} object.\n */\nexport function Query<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables,\n>(props: QueryProps<Data, Variables>): ReactElement<any> {\n  const query = useQuery<Data, Variables>(props);\n  return props.children({ ...query[0], executeQuery: query[1] });\n}\n","import type { ReactElement } from 'react';\nimport type { AnyVariables } from '@urql/core';\n\nimport type {\n  UseSubscriptionArgs,\n  UseSubscriptionState,\n  UseSubscriptionExecute,\n  SubscriptionHandler,\n} from '../hooks';\nimport { useSubscription } from '../hooks';\n\n/** Props accepted by {@link Subscription}.\n *\n * @remarks\n * `SubscriptionProps` are the props accepted by the {@link Subscription} component,\n * which is identical to {@link UseSubscriptionArgs} with an added\n * {@link SubscriptionProps.handler} prop, which {@link useSubscription} usually\n * accepts as an additional argument.\n *\n * The result, the {@link SubscriptionState} object, will be passed to\n * a {@link SubscriptionProps.children} function, passed as children\n * to the `Subscription` component.\n */\nexport type SubscriptionProps<\n  Data = any,\n  Result = Data,\n  Variables extends AnyVariables = AnyVariables,\n> = UseSubscriptionArgs<Variables, Data> & {\n  handler?: SubscriptionHandler<Data, Result>;\n  children(arg: SubscriptionState<Result, Variables>): ReactElement<any>;\n};\n\n/** Object that {@link SubscriptionProps.children} is called with.\n *\n * @remarks\n * This is an extented {@link UseSubscriptionState} with an added\n * {@link SubscriptionState.executeSubscription} method, which is usually\n * part of a tuple returned by {@link useSubscription}.\n */\nexport interface SubscriptionState<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables,\n> extends UseSubscriptionState<Data, Variables> {\n  /** Alias to {@link useSubscription}s `executeMutation` function. */\n  executeSubscription: UseSubscriptionExecute;\n}\n\n/** Component Wrapper around {@link useSubscription} to run a GraphQL subscription.\n *\n * @remarks\n * `Subscription` is a component wrapper around the {@link useSubscription} hook\n * that calls the {@link SubscriptionProps.children} prop, as a function,\n * with the {@link SubscriptionState} object.\n */\nexport function Subscription<\n  Data = any,\n  Result = Data,\n  Variables extends AnyVariables = AnyVariables,\n>(props: SubscriptionProps<Data, Result, Variables>): ReactElement<any> {\n  const subscription = useSubscription<Data, Result, Variables>(\n    props,\n    props.handler\n  );\n\n  return props.children({\n    ...subscription[0],\n    executeSubscription: subscription[1],\n  });\n}\n","import {\n  stringifyDocument,\n  getOperationName,\n  stringifyVariables,\n  extractFiles,\n} from '../utils';\n\nimport type { AnyVariables, GraphQLRequest, Operation } from '../types';\n\n/** Abstract definition of the JSON data sent during GraphQL HTTP POST requests. */\nexport interface FetchBody {\n  query?: string;\n  documentId?: string;\n  operationName: string | undefined;\n  variables: undefined | Record<string, any>;\n  extensions: undefined | Record<string, any>;\n}\n\n/** Creates a GraphQL over HTTP compliant JSON request body.\n * @param request - An object containing a `query` document and `variables`.\n * @returns A {@link FetchBody}\n * @see {@link https://github.com/graphql/graphql-over-http} for the GraphQL over HTTP spec.\n */\nexport function makeFetchBody<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables,\n>(request: Omit<GraphQLRequest<Data, Variables>, 'key'>): FetchBody {\n  const body: FetchBody = {\n    query: undefined,\n    documentId: undefined,\n    operationName: getOperationName(request.query),\n    variables: request.variables || undefined,\n    extensions: request.extensions,\n  };\n\n  if (\n    'documentId' in request.query &&\n    request.query.documentId &&\n    // NOTE: We have to check that the document will definitely be sent\n    // as a persisted document to avoid breaking changes\n    (!request.query.definitions || !request.query.definitions.length)\n  ) {\n    body.documentId = request.query.documentId;\n  } else if (\n    !request.extensions ||\n    !request.extensions.persistedQuery ||\n    !!request.extensions.persistedQuery.miss\n  ) {\n    body.query = stringifyDocument(request.query);\n  }\n\n  return body;\n}\n\n/** Creates a URL that will be called for a GraphQL HTTP request.\n *\n * @param operation - An {@link Operation} for which to make the request.\n * @param body - A {@link FetchBody} which may be replaced with a URL.\n *\n * @remarks\n * Creates the URL thatll be called as part of a GraphQL HTTP request.\n * Built-in fetch exchanges support sending GET requests, even for\n * non-persisted full requests, which this function supports by being\n * able to serialize GraphQL requests into the URL.\n */\nexport const makeFetchURL = (\n  operation: Operation,\n  body?: FetchBody\n): string => {\n  const useGETMethod =\n    operation.kind === 'query' && operation.context.preferGetMethod;\n  if (!useGETMethod || !body) return operation.context.url;\n\n  const urlParts = splitOutSearchParams(operation.context.url);\n  for (const key in body) {\n    const value = body[key];\n    if (value) {\n      urlParts[1].set(\n        key,\n        typeof value === 'object' ? stringifyVariables(value) : value\n      );\n    }\n  }\n  const finalUrl = urlParts.join('?');\n  if (finalUrl.length > 2047 && useGETMethod !== 'force') {\n    operation.context.preferGetMethod = false;\n    return operation.context.url;\n  }\n\n  return finalUrl;\n};\n\nconst splitOutSearchParams = (\n  url: string\n): readonly [string, URLSearchParams] => {\n  const start = url.indexOf('?');\n  return start > -1\n    ? [url.slice(0, start), new URLSearchParams(url.slice(start + 1))]\n    : [url, new URLSearchParams()];\n};\n\n/** Serializes a {@link FetchBody} into a {@link RequestInit.body} format. */\nconst serializeBody = (\n  operation: Operation,\n  body?: FetchBody\n): FormData | string | undefined => {\n  const omitBody =\n    operation.kind === 'query' && !!operation.context.preferGetMethod;\n  if (body && !omitBody) {\n    const json = stringifyVariables(body);\n    const files = extractFiles(body.variables);\n    if (files.size) {\n      const form = new FormData();\n      form.append('operations', json);\n      form.append(\n        'map',\n        stringifyVariables({\n          ...[...files.keys()].map(value => [value]),\n        })\n      );\n      let index = 0;\n      for (const file of files.values()) form.append(`${index++}`, file);\n      return form;\n    }\n    return json;\n  }\n};\n\nconst isHeaders = (headers: HeadersInit): headers is Headers =>\n  'has' in headers && !Object.keys(headers).length;\n\n/** Creates a `RequestInit` object for a given `Operation`.\n *\n * @param operation - An {@link Operation} for which to make the request.\n * @param body - A {@link FetchBody} which is added to the options, if the request isnt a GET request.\n *\n * @remarks\n * Creates the fetch options {@link RequestInit} object thatll be passed to the Fetch API\n * as part of a GraphQL over HTTP request. It automatically sets a default `Content-Type`\n * header.\n *\n * @see {@link https://github.com/graphql/graphql-over-http} for the GraphQL over HTTP spec.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API} for the Fetch API spec.\n */\nexport const makeFetchOptions = (\n  operation: Operation,\n  body?: FetchBody\n): RequestInit => {\n  const headers: HeadersInit = {\n    accept:\n      operation.kind === 'subscription'\n        ? 'text/event-stream, multipart/mixed'\n        : 'application/graphql-response+json, application/graphql+json, application/json, text/event-stream, multipart/mixed',\n  };\n  const extraOptions =\n    (typeof operation.context.fetchOptions === 'function'\n      ? operation.context.fetchOptions()\n      : operation.context.fetchOptions) || {};\n  if (extraOptions.headers) {\n    if (isHeaders(extraOptions.headers)) {\n      extraOptions.headers.forEach((value, key) => {\n        headers[key] = value;\n      });\n    } else if (Array.isArray(extraOptions.headers)) {\n      (extraOptions.headers as Array<[string, string]>).forEach(\n        (value, key) => {\n          if (Array.isArray(value)) {\n            if (headers[value[0]]) {\n              headers[value[0]] = `${headers[value[0]]},${value[1]}`;\n            } else {\n              headers[value[0]] = value[1];\n            }\n          } else {\n            headers[key] = value;\n          }\n        }\n      );\n    } else {\n      for (const key in extraOptions.headers) {\n        headers[key.toLowerCase()] = extraOptions.headers[key];\n      }\n    }\n  }\n\n  const serializedBody = serializeBody(operation, body);\n  if (typeof serializedBody === 'string' && !headers['content-type'])\n    headers['content-type'] = 'application/json';\n  return {\n    ...extraOptions,\n    method: serializedBody ? 'POST' : 'GET',\n    body: serializedBody,\n    headers,\n  };\n};\n","import type { Subscription, Source } from 'wonka';\nimport { filter, make, merge, mergeMap, pipe, takeUntil } from 'wonka';\n\nimport {\n  makeResult,\n  mergeResultPatch,\n  makeErrorResult,\n  makeOperation,\n} from '../utils';\n\nimport type {\n  Exchange,\n  ExecutionResult,\n  Operation,\n  OperationResult,\n} from '../types';\n\nimport type { FetchBody } from '../internal';\nimport { makeFetchBody } from '../internal';\n\n/** An abstract observer-like interface.\n *\n * @remarks\n * Observer-like interfaces are passed to {@link ObservableLike.subscribe} to provide them\n * with callbacks for their events.\n *\n * @see {@link https://github.com/tc39/proposal-observable} for the full TC39 Observable proposal.\n */\nexport interface ObserverLike<T> {\n  /** Callback for values an {@link ObservableLike} emits. */\n  next: (value: T) => void;\n  /** Callback for an error an {@link ObservableLike} emits, which ends the subscription. */\n  error: (err: any) => void;\n  /** Callback for the completion of an {@link ObservableLike}, which ends the subscription. */\n  complete: () => void;\n}\n\n/** An abstract observable-like interface.\n *\n * @remarks\n * Observable, or Observable-like interfaces, are often used by GraphQL transports to abstract\n * how they send {@link ExecutionResult | ExecutionResults} to consumers. These generally contain\n * a `subscribe` method accepting an {@link ObserverLike} structure.\n *\n * @see {@link https://github.com/tc39/proposal-observable} for the full TC39 Observable proposal.\n */\nexport interface ObservableLike<T> {\n  /** Start the Observable-like subscription and returns a subscription handle.\n   *\n   * @param observer - an {@link ObserverLike} object with result, error, and completion callbacks.\n   * @returns a subscription handle providing an `unsubscribe` method to stop the subscription.\n   */\n  subscribe(observer: ObserverLike<T>): {\n    unsubscribe: () => void;\n  };\n}\n\n/** A more cross-compatible version of the {@link GraphQLRequest} structure.\n * {@link FetchBody} for more details\n */\nexport type SubscriptionOperation = FetchBody;\n\n/** A subscription forwarding function, which must accept a {@link SubscriptionOperation}.\n *\n * @param operation - A {@link SubscriptionOperation}\n * @returns An {@link ObservableLike} object issuing {@link ExecutionResult | ExecutionResults}.\n */\nexport type SubscriptionForwarder = (\n  request: FetchBody,\n  operation: Operation\n) => ObservableLike<ExecutionResult>;\n\n/** This is called to create a subscription and needs to be hooked up to a transport client. */\nexport interface SubscriptionExchangeOpts {\n  /** A subscription forwarding function, which must accept a {@link SubscriptionOperation}.\n   *\n   * @param operation - A {@link SubscriptionOperation}\n   * @returns An {@link ObservableLike} object issuing {@link ExecutionResult | ExecutionResults}.\n   *\n   * @remarks\n   * This callback is called for each {@link Operation} that this `subscriptionExchange` will\n   * handle. It receives the {@link SubscriptionOperation}, which is a more compatible version\n   * of the raw {@link Operation} objects and must return an {@link ObservableLike} of results.\n   */\n  forwardSubscription: SubscriptionForwarder;\n\n  /** Flag to enable this exchange to handle all types of GraphQL operations.\n   *\n   * @remarks\n   * When you arent using fetch exchanges and GraphQL over HTTP as a transport for your GraphQL requests,\n   * or you have a third-party GraphQL transport implementation, which must also be used for queries and\n   * mutations, this flag may be used to allow this exchange to handle all kinds of GraphQL operations.\n   *\n   * By default, this flag is `false` and the exchange will only handle GraphQL subscription operations.\n   */\n  enableAllOperations?: boolean;\n\n  /** A predicate function that causes an operation to be handled by this `subscriptionExchange` if `true` is returned.\n   *\n   * @param operation - an {@link Operation}\n   * @returns true when the operation is handled by this exchange.\n   *\n   * @remarks\n   * In some cases, a `subscriptionExchange` will be used to only handle some {@link Operation | Operations},\n   * e.g. all that contain `@live` directive. For these cases, this function may be passed to precisely\n   * determine which `Operation`s this exchange should handle, instead of forwarding.\n   *\n   * When specified, the {@link SubscriptionExchangeOpts.enableAllOperations} flag is disregarded.\n   */\n  isSubscriptionOperation?: (operation: Operation) => boolean;\n}\n\n/** Generic subscription exchange factory used to either create an exchange handling just subscriptions or all operation kinds.\n *\n * @remarks\n * `subscriptionExchange` can be used to create an {@link Exchange} that either\n * handles just GraphQL subscription operations, or optionally all operations,\n * when the {@link SubscriptionExchangeOpts.enableAllOperations} flag is passed.\n *\n * The {@link SubscriptionExchangeOpts.forwardSubscription} function must\n * be provided and provides a generic input that's based on {@link Operation}\n * but is compatible with many libraries implementing GraphQL request or\n * subscription interfaces.\n */\nexport const subscriptionExchange =\n  ({\n    forwardSubscription,\n    enableAllOperations,\n    isSubscriptionOperation,\n  }: SubscriptionExchangeOpts): Exchange =>\n  ({ client, forward }) => {\n    const createSubscriptionSource = (\n      operation: Operation\n    ): Source<OperationResult> => {\n      const observableish = forwardSubscription(\n        makeFetchBody(operation),\n        operation\n      );\n\n      return make<OperationResult>(observer => {\n        let isComplete = false;\n        let sub: Subscription | void;\n        let result: OperationResult | void;\n\n        function nextResult(value: ExecutionResult) {\n          observer.next(\n            (result = result\n              ? mergeResultPatch(result, value)\n              : makeResult(operation, value))\n          );\n        }\n\n        Promise.resolve().then(() => {\n          if (isComplete) return;\n\n          sub = observableish.subscribe({\n            next: nextResult,\n            error(error) {\n              if (Array.isArray(error)) {\n                // NOTE: This is an exception for transports that deliver `GraphQLError[]`, as part\n                // of the observers error callback (may happen as part of `graphql-ws`).\n                // We only check for arrays here, as this is an extremely unexpected case as the\n                // shape of `ExecutionResult` is instead strictly defined.\n                nextResult({ errors: error });\n              } else {\n                observer.next(makeErrorResult(operation, error));\n              }\n              observer.complete();\n            },\n            complete() {\n              if (!isComplete) {\n                isComplete = true;\n                if (operation.kind === 'subscription') {\n                  client.reexecuteOperation(\n                    makeOperation('teardown', operation, operation.context)\n                  );\n                }\n                if (result && result.hasNext) {\n                  nextResult({ hasNext: false });\n                }\n                observer.complete();\n              }\n            },\n          });\n        });\n\n        return () => {\n          isComplete = true;\n          if (sub) sub.unsubscribe();\n        };\n      });\n    };\n\n    const isSubscriptionOperationFn =\n      isSubscriptionOperation ||\n      (operation =>\n        operation.kind === 'subscription' ||\n        (!!enableAllOperations &&\n          (operation.kind === 'query' || operation.kind === 'mutation')));\n\n    return ops$ => {\n      const subscriptionResults$ = pipe(\n        ops$,\n        filter(\n          operation =>\n            operation.kind !== 'teardown' &&\n            isSubscriptionOperationFn(operation)\n        ),\n        mergeMap(operation => {\n          const { key } = operation;\n          const teardown$ = pipe(\n            ops$,\n            filter(op => op.kind === 'teardown' && op.key === key)\n          );\n\n          return pipe(\n            createSubscriptionSource(operation),\n            takeUntil(teardown$)\n          );\n        })\n      );\n\n      const forward$ = pipe(\n        ops$,\n        filter(\n          operation =>\n            operation.kind === 'teardown' ||\n            !isSubscriptionOperationFn(operation)\n        ),\n        forward\n      );\n\n      return merge([subscriptionResults$, forward$]);\n    };\n  };\n","/* Summary: This file handles the HTTP transport via GraphQL over HTTP\n * See: https://graphql.github.io/graphql-over-http/draft/\n *\n * `@urql/core`, by default, implements several RFC'd protocol extensions\n * on top of this. As such, this implementation supports:\n * - [Incremental Delivery](https://github.com/graphql/graphql-over-http/blob/main/rfcs/IncrementalDelivery.md)\n * - [GraphQL over SSE](https://github.com/graphql/graphql-over-http/blob/main/rfcs/GraphQLOverSSE.md)\n *\n * This also supports the \"Defer Stream\" payload format.\n * See: https://github.com/graphql/graphql-wg/blob/main/rfcs/DeferStream.md\n * Implementation for this is located in `../utils/result.ts` in `mergeResultPatch`\n *\n * And; this also supports the GraphQL Multipart spec for file uploads.\n * See: https://github.com/jaydenseric/graphql-multipart-request-spec\n * Implementation for this is located in `../utils/variables.ts` in `extractFiles`,\n * and `./fetchOptions.ts` in `serializeBody`.\n *\n * And; this also supports GET requests (and hence; automatic persisted queries)\n * via the `@urql/exchange-persisted` package.\n *\n * This implementation DOES NOT support Batching.\n * See: https://github.com/graphql/graphql-over-http/blob/main/rfcs/Batching.md\n * Which is deemed out-of-scope, as it's sufficiently unnecessary given\n * modern handling of HTTP requests being in parallel.\n *\n * The implementation in this file needs to make certain accommodations for:\n * - The Web Fetch API\n * - Non-browser or polyfill Fetch APIs\n * - Node.js-like Fetch implementations (see `toString` below)\n *\n * GraphQL over SSE has a reference implementation, which supports non-HTTP/2\n * modes and is a faithful implementation of the spec.\n * See: https://github.com/enisdenjo/graphql-sse\n *\n * GraphQL Inremental Delivery (aka GraphQL Multipart Responses) has a\n * reference implementation, which a prior implementation of this file heavily\n * leaned on (See prior attribution comments)\n * See: https://github.com/maraisr/meros\n *\n * This file merges support for all three GraphQL over HTTP response formats\n * via async generators and Wonkas `fromAsyncIterable`. As part of this, `streamBody`\n * and `split` are the common, cross-compatible base implementations.\n */\n\nimport type { Source } from 'wonka';\nimport { fromAsyncIterable, onEnd, filter, pipe } from 'wonka';\nimport type { Operation, OperationResult, ExecutionResult } from '../types';\nimport { makeResult, makeErrorResult, mergeResultPatch } from '../utils';\n\nconst decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder() : null;\nconst boundaryHeaderRe = /boundary=\"?([^=\";]+)\"?/i;\nconst eventStreamRe = /data: ?([^\\n]+)/;\n\ntype ChunkData = Buffer | Uint8Array;\n\n// NOTE: We're avoiding referencing the `Buffer` global here to prevent\n// auto-polyfilling in Webpack\nconst toString = (input: Buffer | ArrayBuffer): string =>\n  input.constructor.name === 'Buffer'\n    ? (input as Buffer).toString()\n    : decoder!.decode(input as ArrayBuffer);\n\nasync function* streamBody(response: Response): AsyncIterableIterator<string> {\n  if (response.body![Symbol.asyncIterator]) {\n    for await (const chunk of response.body! as any)\n      yield toString(chunk as ChunkData);\n  } else {\n    const reader = response.body!.getReader();\n    let result: ReadableStreamReadResult<ChunkData>;\n    try {\n      while (!(result = await reader.read()).done) yield toString(result.value);\n    } finally {\n      reader.cancel();\n    }\n  }\n}\n\nasync function* split(\n  chunks: AsyncIterableIterator<string>,\n  boundary: string\n): AsyncIterableIterator<string> {\n  let buffer = '';\n  let boundaryIndex: number;\n  for await (const chunk of chunks) {\n    buffer += chunk;\n    while ((boundaryIndex = buffer.indexOf(boundary)) > -1) {\n      yield buffer.slice(0, boundaryIndex);\n      buffer = buffer.slice(boundaryIndex + boundary.length);\n    }\n  }\n}\n\nasync function* parseJSON(\n  response: Response\n): AsyncIterableIterator<ExecutionResult> {\n  yield JSON.parse(await response.text());\n}\n\nasync function* parseEventStream(\n  response: Response\n): AsyncIterableIterator<ExecutionResult> {\n  let payload: any;\n  for await (const chunk of split(streamBody(response), '\\n\\n')) {\n    const match = chunk.match(eventStreamRe);\n    if (match) {\n      const chunk = match[1];\n      try {\n        yield (payload = JSON.parse(chunk));\n      } catch (error) {\n        if (!payload) throw error;\n      }\n      if (payload && payload.hasNext === false) break;\n    }\n  }\n  if (payload && payload.hasNext !== false) {\n    yield { hasNext: false };\n  }\n}\n\nasync function* parseMultipartMixed(\n  contentType: string,\n  response: Response\n): AsyncIterableIterator<ExecutionResult> {\n  const boundaryHeader = contentType.match(boundaryHeaderRe);\n  const boundary = '--' + (boundaryHeader ? boundaryHeader[1] : '-');\n  let isPreamble = true;\n  let payload: any;\n  for await (let chunk of split(streamBody(response), '\\r\\n' + boundary)) {\n    if (isPreamble) {\n      isPreamble = false;\n      const preambleIndex = chunk.indexOf(boundary);\n      if (preambleIndex > -1) {\n        chunk = chunk.slice(preambleIndex + boundary.length);\n      } else {\n        continue;\n      }\n    }\n    try {\n      yield (payload = JSON.parse(chunk.slice(chunk.indexOf('\\r\\n\\r\\n') + 4)));\n    } catch (error) {\n      if (!payload) throw error;\n    }\n    if (payload && payload.hasNext === false) break;\n  }\n  if (payload && payload.hasNext !== false) {\n    yield { hasNext: false };\n  }\n}\n\nasync function* parseMaybeJSON(\n  response: Response\n): AsyncIterableIterator<ExecutionResult> {\n  const text = await response.text();\n  try {\n    const result = JSON.parse(text);\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn(\n        `Found response with content-type \"text/plain\" but it had a valid \"application/json\" response.`\n      );\n    }\n    yield result;\n  } catch (e) {\n    throw new Error(text);\n  }\n}\n\nasync function* fetchOperation(\n  operation: Operation,\n  url: string,\n  fetchOptions: RequestInit\n) {\n  let networkMode = true;\n  let result: OperationResult | null = null;\n  let response: Response | undefined;\n\n  try {\n    // Delay for a tick to give the Client a chance to cancel the request\n    // if a teardown comes in immediately\n    yield await Promise.resolve();\n\n    response = await (operation.context.fetch || fetch)(url, fetchOptions);\n    const contentType = response.headers.get('Content-Type') || '';\n\n    let results: AsyncIterable<ExecutionResult>;\n    if (/multipart\\/mixed/i.test(contentType)) {\n      results = parseMultipartMixed(contentType, response);\n    } else if (/text\\/event-stream/i.test(contentType)) {\n      results = parseEventStream(response);\n    } else if (!/text\\//i.test(contentType)) {\n      results = parseJSON(response);\n    } else {\n      results = parseMaybeJSON(response);\n    }\n\n    let pending: ExecutionResult['pending'];\n    for await (const payload of results) {\n      if (payload.pending && !result) {\n        pending = payload.pending;\n      } else if (payload.pending) {\n        pending = [...pending!, ...payload.pending];\n      }\n      result = result\n        ? mergeResultPatch(result, payload, response, pending)\n        : makeResult(operation, payload, response);\n      networkMode = false;\n      yield result;\n      networkMode = true;\n    }\n\n    if (!result) {\n      yield (result = makeResult(operation, {}, response));\n    }\n  } catch (error: any) {\n    if (!networkMode) {\n      throw error;\n    }\n\n    yield makeErrorResult(\n      operation,\n      response &&\n        (response.status < 200 || response.status >= 300) &&\n        response.statusText\n        ? new Error(response.statusText)\n        : error,\n      response\n    );\n  }\n}\n\n/** Makes a GraphQL HTTP request to a given API by wrapping around the Fetch API.\n *\n * @param operation - The {@link Operation} that should be sent via GraphQL over HTTP.\n * @param url - The endpoint URL for the GraphQL HTTP API.\n * @param fetchOptions - The {@link RequestInit} fetch options for the request.\n * @returns A Wonka {@link Source} of {@link OperationResult | OperationResults}.\n *\n * @remarks\n * This utility defines how all built-in fetch exchanges make GraphQL HTTP requests,\n * supporting multipart incremental responses, cancellation and other smaller\n * implementation details.\n *\n * If youre implementing a modified fetch exchange for a GraphQL over HTTP API\n * its recommended you use this utility.\n *\n * Hint: This function does not use the passed `operation` to create or modify the\n * `fetchOptions` and instead expects that the options have already been created\n * using {@link makeFetchOptions} and modified as needed.\n *\n * @throws\n * If the `fetch` polyfill or globally available `fetch` function doesnt support\n * streamed multipart responses while trying to handle a `multipart/mixed` GraphQL response,\n * the source will throw Streaming requests unsupported.\n * This shouldnt happen in modern browsers and Node.js.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API} for the Fetch API spec.\n */\nexport function makeFetchSource(\n  operation: Operation,\n  url: string,\n  fetchOptions: RequestInit\n): Source<OperationResult> {\n  let abortController: AbortController | void;\n  if (typeof AbortController !== 'undefined') {\n    fetchOptions.signal = (abortController = new AbortController()).signal;\n  }\n  return pipe(\n    fromAsyncIterable(fetchOperation(operation, url, fetchOptions)),\n    filter((result): result is OperationResult => !!result),\n    onEnd(() => {\n      if (abortController) abortController.abort();\n    })\n  );\n}\n","import { pipe, tap } from 'wonka';\nimport type { Exchange } from '../types';\n\n/** Simple log debugger exchange.\n *\n * @remarks\n * An exchange that logs incoming {@link Operation | Operations} and\n * {@link OperationResult | OperationResults} in development.\n *\n * This exchange is a no-op in production and often used in issue reporting\n * to understand certain usage patterns of `urql` without having access to\n * the original source code.\n *\n * Hint: When you report an issue youre having with `urql`, adding\n * this as your first exchange and posting its output can speed up\n * issue triaging a lot!\n */\nexport const debugExchange: Exchange = ({ forward }) => {\n  if (process.env.NODE_ENV === 'production') {\n    return ops$ => forward(ops$);\n  } else {\n    return ops$ =>\n      pipe(\n        ops$,\n        // eslint-disable-next-line no-console\n        tap(op => console.log('[Exchange debug]: Incoming operation: ', op)),\n        forward,\n        tap(result =>\n          // eslint-disable-next-line no-console\n          console.log('[Exchange debug]: Completed operation: ', result)\n        )\n      );\n  }\n};\n","import type { Exchange } from '../types';\n\n/** Default deduplication exchange.\n * @deprecated\n * This exchange's functionality is now built into the {@link Client}.\n */\nexport const dedupExchange: Exchange =\n  ({ forward }) =>\n  ops$ =>\n    forward(ops$);\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { filter, merge, mergeMap, pipe, takeUntil, onPush } from 'wonka';\n\nimport type { Exchange } from '../types';\nimport {\n  makeFetchBody,\n  makeFetchURL,\n  makeFetchOptions,\n  makeFetchSource,\n} from '../internal';\n\n/** Default GraphQL over HTTP fetch exchange.\n *\n * @remarks\n * The default fetch exchange in `urql` supports sending GraphQL over HTTP\n * requests, can optionally send GraphQL queries as GET requests, and\n * handles incremental multipart responses.\n *\n * This exchange does not handle persisted queries or multipart uploads.\n * Support for the former can be added using `@urql/exchange-persisted-fetch`\n * and the latter using `@urql/exchange-multipart-fetch`.\n *\n * Hint: The `fetchExchange` and the two other exchanges all use the built-in fetch\n * utilities in `@urql/core/internal`, which you can also use to implement\n * a customized fetch exchange.\n *\n * @see {@link makeFetchSource} for the shared utility calling the Fetch API.\n */\nexport const fetchExchange: Exchange = ({ forward, dispatchDebug }) => {\n  return ops$ => {\n    const fetchResults$ = pipe(\n      ops$,\n      filter(operation => {\n        return (\n          operation.kind !== 'teardown' &&\n          (operation.kind !== 'subscription' ||\n            !!operation.context.fetchSubscriptions)\n        );\n      }),\n      mergeMap(operation => {\n        const body = makeFetchBody(operation);\n        const url = makeFetchURL(operation, body);\n        const fetchOptions = makeFetchOptions(operation, body);\n\n        dispatchDebug({\n          type: 'fetchRequest',\n          message: 'A fetch request is being executed.',\n          operation,\n          data: {\n            url,\n            fetchOptions,\n          },\n        });\n\n        const source = pipe(\n          makeFetchSource(operation, url, fetchOptions),\n          takeUntil(\n            pipe(\n              ops$,\n              filter(op => op.kind === 'teardown' && op.key === operation.key)\n            )\n          )\n        );\n\n        if (process.env.NODE_ENV !== 'production') {\n          return pipe(\n            source,\n            onPush(result => {\n              const error = !result.data ? result.error : undefined;\n\n              dispatchDebug({\n                type: error ? 'fetchError' : 'fetchSuccess',\n                message: `A ${\n                  error ? 'failed' : 'successful'\n                } fetch response has been returned.`,\n                operation,\n                data: {\n                  url,\n                  fetchOptions,\n                  value: error || result,\n                },\n              });\n            })\n          );\n        }\n\n        return source;\n      })\n    );\n\n    const forward$ = pipe(\n      ops$,\n      filter(operation => {\n        return (\n          operation.kind === 'teardown' ||\n          (operation.kind === 'subscription' &&\n            !operation.context.fetchSubscriptions)\n        );\n      }),\n      forward\n    );\n\n    return merge([fetchResults$, forward$]);\n  };\n};\n","import { share } from 'wonka';\nimport type { ExchangeIO, Exchange, ExchangeInput } from '../types';\n\n/** Composes an array of Exchanges into a single one.\n *\n * @param exchanges - An array of {@link Exchange | Exchanges}.\n * @returns - A composed {@link Exchange}.\n *\n * @remarks\n * `composeExchanges` returns an {@link Exchange} that when instantiated\n * composes the array of passed `Exchange`s into one, calling them from\n * right to left, with the prior `Exchange`s {@link ExchangeIO} function\n * as the {@link ExchangeInput.forward} input.\n *\n * This simply merges all exchanges into one and is used by the {@link Client}\n * to merge the `exchanges` option it receives.\n *\n * @throws\n * In development, if {@link ExchangeInput.forward} is called repeatedly\n * by an {@link Exchange} an error is thrown, since `forward()` must only\n * be called once per `Exchange`.\n */\nexport const composeExchanges =\n  (exchanges: Exchange[]): Exchange =>\n  ({ client, forward, dispatchDebug }: ExchangeInput): ExchangeIO =>\n    exchanges.reduceRight((forward, exchange) => {\n      let forwarded = false;\n      return exchange({\n        client,\n        forward(operations$) {\n          if (process.env.NODE_ENV !== 'production') {\n            if (forwarded)\n              throw new Error(\n                'forward() must only be called once in each Exchange.'\n              );\n            forwarded = true;\n          }\n          return share(forward(share(operations$)));\n        },\n        dispatchDebug(event) {\n          dispatchDebug({\n            timestamp: Date.now(),\n            source: exchange.name,\n            ...event,\n          });\n        },\n      });\n    }, forward);\n","import { mergeMap, fromValue, fromPromise, pipe } from 'wonka';\nimport type { Operation, OperationResult, Exchange } from '../types';\nimport type { CombinedError } from '../utils';\n\n/** Options for the `mapExchange` allowing it to react to incoming operations, results, or errors. */\nexport interface MapExchangeOpts {\n  /** Accepts a callback for incoming `Operation`s.\n   *\n   * @param operation - An {@link Operation} that the {@link mapExchange} received.\n   * @returns optionally a new {@link Operation} replacing the original.\n   *\n   * @remarks\n   * You may return new {@link Operation | Operations} from this function replacing\n   * the original that the {@link mapExchange} received.\n   * Its recommended that you use the {@link makeOperation} utility to create a copy\n   * of the original when you do this. (However, this isnt required)\n   *\n   * Hint: The callback may also be promisified and return a new {@link Operation} asynchronously,\n   * provided you place your {@link mapExchange} after all synchronous {@link Exchange | Exchanges},\n   * like after your `cacheExchange`.\n   */\n  onOperation?(operation: Operation): Promise<Operation> | Operation | void;\n  /** Accepts a callback for incoming `OperationResult`s.\n   *\n   * @param result - An {@link OperationResult} that the {@link mapExchange} received.\n   * @returns optionally a new {@link OperationResult} replacing the original.\n   *\n   * @remarks\n   * This callback may optionally return a new {@link OperationResult} that replaces the original,\n   * which you can use to modify incoming API results.\n   *\n   * Hint: The callback may also be promisified and return a new {@link Operation} asynchronously,\n   * provided you place your {@link mapExchange} after all synchronous {@link Exchange | Exchanges},\n   * like after your `cacheExchange`.\n   */\n  onResult?(\n    result: OperationResult\n  ): Promise<OperationResult> | OperationResult | void;\n  /** Accepts a callback for incoming `CombinedError`s.\n   *\n   * @param error - A {@link CombinedError} that an incoming {@link OperationResult} contained.\n   * @param operation - The {@link Operation} of the incoming {@link OperationResult}.\n   *\n   * @remarks\n   * The callback may also be promisified and return a new {@link Operation} asynchronously,\n   * provided you place your {@link mapExchange} after all synchronous {@link Exchange | Exchanges},\n   * like after your `cacheExchange`.\n   */\n  onError?(error: CombinedError, operation: Operation): void;\n}\n\n/** Creates an `Exchange` mapping over incoming operations, results, and/or errors.\n *\n * @param opts - A {@link MapExchangeOpts} configuration object, containing the callbacks the `mapExchange` will use.\n * @returns the created {@link Exchange}\n *\n * @remarks\n * The `mapExchange` may be used to react to or modify incoming {@link Operation | Operations}\n * and {@link OperationResult | OperationResults}. Optionally, it can also modify these\n * asynchronously, when a promise is returned from the callbacks.\n *\n * This is useful to, for instance, add an authentication token to a given request, when\n * the `@urql/exchange-auth` package would be overkill.\n *\n * It can also accept an `onError` callback, which can be used to react to incoming\n * {@link CombinedError | CombinedErrors} on results, and trigger side-effects.\n *\n */\nexport const mapExchange = ({\n  onOperation,\n  onResult,\n  onError,\n}: MapExchangeOpts): Exchange => {\n  return ({ forward }) =>\n    ops$ => {\n      return pipe(\n        pipe(\n          ops$,\n          mergeMap(operation => {\n            const newOperation =\n              (onOperation && onOperation(operation)) || operation;\n            return 'then' in newOperation\n              ? fromPromise(newOperation)\n              : fromValue(newOperation);\n          })\n        ),\n        forward,\n        mergeMap(result => {\n          if (onError && result.error) onError(result.error, result.operation);\n          const newResult = (onResult && onResult(result)) || result;\n          return 'then' in newResult\n            ? fromPromise(newResult)\n            : fromValue(newResult);\n        })\n      );\n    };\n};\n","import { filter, pipe, tap } from 'wonka';\nimport type { ExchangeIO, ExchangeInput } from '../types';\n\n/** Used by the `Client` as the last exchange to warn about unhandled operations.\n *\n * @remarks\n * In a normal setup, some operations may go unhandled when a {@link Client} isnt set up\n * with the right exchanges.\n * For instance, a `Client` may be missing a fetch exchange, or an exchange handling subscriptions.\n * This {@link Exchange} is added by the `Client` automatically to log warnings about unhandled\n * {@link Operaiton | Operations} in development.\n */\nexport const fallbackExchange: ({\n  dispatchDebug,\n}: Pick<ExchangeInput, 'dispatchDebug'>) => ExchangeIO =\n  ({ dispatchDebug }) =>\n  ops$ => {\n    if (process.env.NODE_ENV !== 'production') {\n      ops$ = pipe(\n        ops$,\n        tap(operation => {\n          if (\n            operation.kind !== 'teardown' &&\n            process.env.NODE_ENV !== 'production'\n          ) {\n            const message = `No exchange has handled operations of kind \"${operation.kind}\". Check whether you've added an exchange responsible for these operations.`;\n\n            dispatchDebug({\n              type: 'fallbackCatch',\n              message,\n              operation,\n            });\n            console.warn(message);\n          }\n        })\n      );\n    }\n\n    // All operations that skipped through the entire exchange chain should be filtered from the output\n    return filter((_x): _x is never => false)(ops$);\n  };\n","/* eslint-disable @typescript-eslint/no-use-before-define */\n\nimport type { Source, Subscription } from 'wonka';\nimport {\n  lazy,\n  filter,\n  makeSubject,\n  onEnd,\n  onPush,\n  onStart,\n  pipe,\n  share,\n  take,\n  takeUntil,\n  takeWhile,\n  publish,\n  subscribe,\n  switchMap,\n  fromValue,\n  merge,\n  map,\n} from 'wonka';\n\nimport { composeExchanges } from './exchanges';\nimport { fallbackExchange } from './exchanges/fallback';\n\nimport type {\n  DocumentInput,\n  AnyVariables,\n  Exchange,\n  ExchangeInput,\n  GraphQLRequest,\n  Operation,\n  OperationInstance,\n  OperationContext,\n  OperationResult,\n  OperationResultSource,\n  OperationType,\n  RequestPolicy,\n  DebugEvent,\n} from './types';\n\nimport {\n  createRequest,\n  withPromise,\n  maskTypename,\n  noop,\n  makeOperation,\n  getOperationType,\n} from './utils';\n\n/** Configuration options passed when creating a new {@link Client}.\n *\n * @remarks\n * The `ClientOptions` are passed when creating a new {@link Client}, and\n * are used to instantiate the pipeline of {@link Exchange | Exchanges}, configure\n * options used to initialize {@link OperationContext | OperationContexts}, or to\n * change the general behaviour of the {@link Client}.\n */\nexport interface ClientOptions {\n  /** Target URL used by fetch exchanges to make GraphQL API requests to.\n   *\n   * @remarks\n   * This is the URL that fetch exchanges will call to make GraphQL API requests.\n   * This value is copied to {@link OperationContext.url}.\n   */\n  url: string;\n  /** Additional options used by fetch exchanges that'll be passed to the `fetch` call on API requests.\n   *\n   * @remarks\n   * The options in this object or an object returned by a callback function will be merged into the\n   * {@link RequestInit} options passed to the `fetch` call.\n   *\n   * Hint: If you're trying to implement more complex changes per {@link Operation}, it's worth considering\n   * to use the {@link mapExchange} instead, which allows you to change `Operation`s and `OperationResult`s.\n   *\n   * Hint: If you're trying to use this as a function for authentication, consider checking out\n   * `@urql/exchange-auth` instead, which allows you to handle refresh auth flows, and more\n   * complex auth flows.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/fetch} for a description of this object.\n   */\n  fetchOptions?: RequestInit | (() => RequestInit);\n  /** A `fetch` function polyfill used by fetch exchanges to make API calls.\n   *\n   * @remarks\n   * This is the fetch polyfill used by any fetch exchange to make an API request. By default, when this\n   * option isn't set, any fetch exchange will attempt to use the globally available `fetch` function\n   * to make a request instead.\n   *\n   * It's recommended to only pass a polyfill, if any of the environments you're running the {@link Client}\n   * in don't support the Fetch API natively.\n   *\n   * Hint: If you're using the \"Incremental Delivery\" multipart spec, for instance with `@defer` directives,\n   * you're better off using the native `fetch` function, or must ensure that your polyfill supports streamed\n   * results. However, a \"Streaming requests unsupported\" error will be thrown, to let you know that your `fetch`\n   * API doesn't support incrementally streamed responses, if this mode is used.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API} for the Fetch API spec.\n   */\n  fetch?: typeof fetch;\n  /** Allows a subscription to be executed using a `fetch` API request.\n   *\n   * @remarks\n   * If your API supports the `text/event-stream` and/or `multipart/mixed` response protocol, and you use\n   * this protocol to handle subscriptions, then you may switch this flag to `true`.\n   *\n   * This means you wont have to create a {@link subscriptionExchange} to handle subscriptions with an\n   * external transport, and will instead be able to use GraphQL over HTTP transports.\n   */\n  fetchSubscriptions?: boolean;\n  /** A list of `Exchange`s that will be used to create the `Client`'s execution pipeline.\n   *\n   * @remarks\n   * The {@link Client} accepts and composes a list of {@link Exchange | Exchanges} into an exchange pipeline\n   * which receive a stream of {@link Operation | Operations} the `Client` wishes to execute, and return a stream\n   * of {@link OperationResult | OperationResults}.\n   *\n   * This is the basis for how `urql` handles GraphQL operations, and exchanges handle the creation, execution,\n   * and control flow of exchanges for the `Client`.\n   *\n   * To easily get started you should consider using the {@link dedupExchange}, {@link cacheExchange} and {@link fetchExchange}\n   * these are all exported from the core package.\n   *\n   * @see {@link https://urql.dev/goto/docs/architecture/#the-client-and-exchanges} for more information\n   * on what `Exchange`s are and how they work.\n   */\n  exchanges: Exchange[];\n  /** A configuration flag indicating whether support for \"Suspense\" is activated.\n   *\n   * @remarks\n   * This configuration flag is only relevant for using `urql` with the React or Preact bindings.\n   * When activated it allows `useQuery` to \"suspend\" instead of returning a loading state, which\n   * will stop updates in a querying component and instead cascade\n   * to a higher suspense boundary for a loading state.\n   *\n   * Hint: While, when this option is enabled, by default all `useQuery` hooks will suspense, you can\n   * disable Suspense selectively for each hook.\n   *\n   * @see {@link https://beta.reactjs.org/blog/2022/03/29/react-v18#new-suspense-features} for more information on React Suspense.\n   */\n  suspense?: boolean;\n  /** The request and caching strategy that all `Operation`s on this `Client` will use by default.\n   *\n   * @remarks\n   * The {@link RequestPolicy} instructs cache exchanges how to use and treat their cached results.\n   * By default `cache-first` is set and used, which will use cache results, and only make an API request\n   * on a cache miss.\n   *\n   * The `requestPolicy` can be overriden per operation, since it's added to the {@link OperationContext},\n   * which allows you to change the policy per `Operation`, rather than changing it by default here.\n   *\n   * Hint: We dont recommend changing this from the default `cache-first` option, unless you know what\n   * youre doing. Setting this to `cache-and-network` is not recommend and may not lead to the behaviour\n   * you expect. If youre looking to always update your cache frequently, use `@urql/exchange-request-policy`\n   * instead.\n   */\n  requestPolicy?: RequestPolicy;\n  /** Instructs fetch exchanges to use a GET request.\n   *\n   * @remarks\n   * This changes the {@link OperationContext.preferGetMethod} option, which tells fetch exchanges\n   * to use GET requests for queries instead of POST requests.\n   *\n   * When set to `true` or `'within-url-limit'`, built-in fetch exchanges will always attempt to send query\n   * operations as GET requests, unless the resulting URL exceeds a length of 2,048 characters.\n   * If you want to bypass this restriction, set this option to `'force'` instead, to always send GET.\n   * requests for queries.\n   */\n  preferGetMethod?: boolean | 'force' | 'within-url-limit';\n  /** Instructs the `Client` to remove `__typename` properties on all results.\n   *\n   * @deprecated Not recommended over modelling inputs manually (See #3299)\n   *\n   * @remarks\n   * By default, cache exchanges will alter your GraphQL documents to request `__typename` fields\n   * for all selections. However, this means that your GraphQL data will now contain `__typename` fields you\n   * didn't ask for. This is why the {@link Client} supports masking this field by marking it\n   * as non-enumerable via this option.\n   *\n   * Only use this option if you absolutely have to. It's popular to model mutation inputs in\n   * GraphQL schemas after the object types they modify, and if you're using this option to make\n   * it possible to directly pass objects from results as inputs to your mutation variables, it's\n   * more performant and idomatic to instead create a new input object.\n   *\n   * Hint: With `@urql/exchange-graphcache` you will never need this option, as it selects fields on\n   * the client-side according to which fields you specified, rather than the fields it modified.\n   *\n   * @see {@link https://spec.graphql.org/October2021/#sec-Type-Name-Introspection} for more information\n   * on typename introspection via the `__typename` field.\n   */\n  maskTypename?: boolean;\n}\n\n/** The `Client` is the central hub for your GraphQL operations and holds `urql`'s state.\n *\n * @remarks\n * The `Client` manages your active GraphQL operations and their state, and contains the\n * {@link Exchange} pipeline to execute your GraphQL operations.\n *\n * It contains methods that allow you to execute GraphQL operations manually, but the `Client`\n * is also interacted with by bindings (for React, Preact, Vue, Svelte, etc) to execute GraphQL\n * operations.\n *\n * While {@link Exchange | Exchanges} are ultimately responsible for the control flow of operations,\n * sending API requests, and caching, the `Client` still has the important responsibility for\n * creating operations, managing consumers of active operations, sharing results for operations,\n * and more tasks as a central hub.\n *\n * @see {@link https://urql.dev/goto/docs/architecture/#requests-and-operations-on-the-client} for more information\n * on what the `Client` is and does.\n */\nexport interface Client {\n  new (options: ClientOptions): Client;\n\n  /** Exposes the stream of `Operation`s that is passed to the `Exchange` pipeline.\n   *\n   * @remarks\n   * This is a Wonka {@link Source} that issues the {@link Operation | Operations} going into\n   * the exchange pipeline.\n   * @internal\n   */\n  operations$: Source<Operation>;\n\n  /** Flag indicating whether support for Suspense is activated.\n   *\n   * @remarks\n   * This flag indicates whether support for Suspense has been activated via the\n   * {@link ClientOptions.suspense} flag.\n   *\n   * When this is enabled, the {@link Client} itself doesnt function any differently, and the flag\n   * only serves as an instructions for the React/Preact bindings to change their behaviour.\n   *\n   * @see {@link ClientOptions.suspense} for more information.\n   * @internal\n   */\n  suspense: boolean;\n\n  /** Dispatches an `Operation` to the `Exchange` pipeline, if this `Operation` is active.\n   *\n   * @remarks\n   * This method is frequently used in {@link Exchange | Exchanges}, for instance caches, to reexecute\n   * an operation. Its often either called because an `Operation` will need to be queried against the\n   * cache again, if a cache result has changed or been invalidated, or its called with an {@link Operation}'s\n   * {@link RequestPolicy} set to `network-only` to issue a network request.\n   *\n   * This method will only dispatch an {@link Operation} if it has active consumers, meaning,\n   * active subscribers to the sources of {@link OperationResult}. For instance, if no bindings\n   * (e.g. `useQuery`) is subscribed to the `Operation`, then `reexecuteOperation` will do nothing.\n   *\n   * All operations are put onto a queue and executed after a micro-tick. The queue of operations is\n   * emptied eagerly and synchronously, similar to a trampoline scheduler.\n   */\n  reexecuteOperation(operation: Operation): void;\n\n  /** Subscribe method to add an event listener to debug events.\n   *\n   * @param onEvent - A callback called with new debug events, each time an `Exchange` issues them.\n   * @returns A Wonka {@link Subscription} which is used to optionally terminate the event listener.\n   *\n   * @remarks\n   * This is a method that's only available in development, and allows the `urql-devtools` to receive\n   * to debug events that are issued by exchanges, giving the devtools more information about the flow\n   * and execution of {@link Operation | Operations}.\n   *\n   * @see {@link DebugEventTypes} for a description of all debug events.\n   * @internal\n   */\n  subscribeToDebugTarget?(onEvent: (event: DebugEvent) => void): Subscription;\n\n  /** Creates an `Operation` from a `GraphQLRequest` and optionally, overriding `OperationContext` options.\n   *\n   * @param kind - The {@link OperationType} of GraphQL operation, i.e. `query`, `mutation`, or `subscription`.\n   * @param request - A {@link GraphQLRequest} created prior to calling this method.\n   * @param opts - {@link OperationContext} options that'll override and be merged with options from the {@link ClientOptions}.\n   * @returns An {@link Operation} created from the parameters.\n   *\n   * @remarks\n   * This method is expected to be called with a `kind` set to the `OperationType` of the GraphQL operation.\n   * In development, this is enforced by checking that the GraphQL document's operation matches this `kind`.\n   *\n   * Hint: While bindings will use this method combined with {@link Client.executeRequestOperation}, if\n   * youre executing operations manually, you can use one of the other convenience methods instead.\n   *\n   * @see {@link Client.executeRequestOperation} for the method used to execute operations.\n   * @see {@link createRequest} which creates a `GraphQLRequest` from a `DocumentNode` and variables.\n   */\n  createRequestOperation<\n    Data = any,\n    Variables extends AnyVariables = AnyVariables,\n  >(\n    kind: OperationType,\n    request: GraphQLRequest<Data, Variables>,\n    opts?: Partial<OperationContext> | undefined\n  ): Operation<Data, Variables>;\n\n  /** Creates a `Source` that executes the `Operation` and issues `OperationResult`s for this `Operation`.\n   *\n   * @param operation - {@link Operation} that will be executed.\n   * @returns A Wonka {@link Source} of {@link OperationResult | OperationResults} for the passed `Operation`.\n   *\n   * @remarks\n   * The {@link Operation} will be dispatched to the pipeline of {@link Exchange | Exchanges} when\n   * subscribing to the returned {@link Source}, which issues {@link OperationResult | OperationResults}\n   * belonging to this `Operation`.\n   *\n   * Internally, {@link OperationResult | OperationResults} are filtered and deliverd to this source by\n   * comparing the {@link Operation.key} on the operation and the {@link OperationResult.operation}.\n   * For mutations, the {@link OperationContext._instance | `OperationContext._instance`} will additionally be compared, since two mutations\n   * with, even given the same variables, will have two distinct results and will be executed separately.\n   *\n   * The {@link Client} dispatches the {@link Operation} when we subscribe to the returned {@link Source}\n   * and will from then on consider the `Operation` as active until we unsubscribe. When all consumers unsubscribe\n   * from an `Operation` and it becomes inactive a `teardown` signal will be dispatched to the\n   * {@link Exchange | Exchanges}.\n   *\n   * Hint: While bindings will use this method, if youre executing operations manually, you can use one\n   * of the other convenience methods instead, like {@link Client.executeQuery} et al.\n   */\n  executeRequestOperation<\n    Data = any,\n    Variables extends AnyVariables = AnyVariables,\n  >(\n    operation: Operation<Data, Variables>\n  ): OperationResultSource<OperationResult<Data, Variables>>;\n\n  /** Creates a `Source` that executes the GraphQL query operation created from the passed parameters.\n   *\n   * @param query - a GraphQL document containing the query operation that will be executed.\n   * @param variables - the variables used to execute the operation.\n   * @param opts - {@link OperationContext} options that'll override and be merged with options from the {@link ClientOptions}.\n   * @returns A {@link OperationResultSource} issuing the {@link OperationResult | OperationResults} for the GraphQL operation.\n   *\n   * @remarks\n   * The `Client.query` method is useful to programmatically create and issue a GraphQL query operation.\n   * It automatically calls {@link createRequest}, {@link client.createRequestOperation}, and\n   * {@link client.executeRequestOperation} for you, and is a convenience method.\n   *\n   * Since it returns a {@link OperationResultSource} it may be chained with a `toPromise()` call to only\n   * await a single result in an async function.\n   *\n   * Hint: This is the recommended way to create queries programmatically when not using the bindings,\n   * or when youre trying to get a single, promisified result.\n   *\n   * @example\n   * ```ts\n   * const getBookQuery = gql`\n   *   query GetBook($id: ID!) {\n   *     book(id: $id) {\n   *       id\n   *       name\n   *       author {\n   *         name\n   *       }\n   *     }\n   *   }\n   * `;\n   *\n   * async function getBook(id) {\n   *   const result = await client.query(getBookQuery, { id }).toPromise();\n   *   if (result.error) {\n   *     throw result.error;\n   *   }\n   *\n   *   return result.data.book;\n   * }\n   * ```\n   */\n  query<Data = any, Variables extends AnyVariables = AnyVariables>(\n    query: DocumentInput<Data, Variables>,\n    variables: Variables,\n    context?: Partial<OperationContext>\n  ): OperationResultSource<OperationResult<Data, Variables>>;\n\n  /** Returns the first synchronous result a `Client` provides for a given operation.\n   *\n   * @param query - a GraphQL document containing the query operation that will be executed.\n   * @param variables - the variables used to execute the operation.\n   * @param opts - {@link OperationContext} options that'll override and be merged with options from the {@link ClientOptions}.\n   * @returns An {@link OperationResult} if one became available synchronously or `null`.\n   *\n   * @remarks\n   * The `Client.readQuery` method returns a result synchronously or defaults to `null`. This is useful\n   * as it limits the result for a query operation to whatever the cache {@link Exchange} of a {@link Client}\n   * had stored and available at that moment.\n   *\n   * In `urql`, it's expected that cache exchanges return their results synchronously. The bindings\n   * and this method exploit this by using synchronous results, like these, to check what data is already\n   * in the cache.\n   *\n   * This method is similar to what all bindings do to synchronously provide the initial state for queries,\n   * regardless of whether effects afterwards that subscribe to the query operation update this state synchronously\n   * or asynchronously.\n   */\n  readQuery<Data = any, Variables extends AnyVariables = AnyVariables>(\n    query: DocumentInput<Data, Variables>,\n    variables: Variables,\n    context?: Partial<OperationContext>\n  ): OperationResult<Data, Variables> | null;\n\n  /** Creates a `Source` that executes the GraphQL query operation for the passed `GraphQLRequest`.\n   *\n   * @param query - a {@link GraphQLRequest}\n   * @param opts - {@link OperationContext} options that'll override and be merged with options from the {@link ClientOptions}.\n   * @returns A {@link PromisifiedSource} issuing the {@link OperationResult | OperationResults} for the GraphQL operation.\n   *\n   * @remarks\n   * The `Client.executeQuery` method is used to programmatically issue a GraphQL query operation.\n   * It automatically calls {@link client.createRequestOperation} and {@link client.executeRequestOperation} for you,\n   * but requires you to create a {@link GraphQLRequest} using {@link createRequest} yourself first.\n   *\n   * @see {@link Client.query} for a method that doesn't require calling {@link createRequest} yourself.\n   */\n  executeQuery<Data = any, Variables extends AnyVariables = AnyVariables>(\n    query: GraphQLRequest<Data, Variables>,\n    opts?: Partial<OperationContext> | undefined\n  ): OperationResultSource<OperationResult<Data, Variables>>;\n\n  /** Creates a `Source` that executes the GraphQL subscription operation created from the passed parameters.\n   *\n   * @param query - a GraphQL document containing the subscription operation that will be executed.\n   * @param variables - the variables used to execute the operation.\n   * @param opts - {@link OperationContext} options that'll override and be merged with options from the {@link ClientOptions}.\n   * @returns A Wonka {@link Source} issuing the {@link OperationResult | OperationResults} for the GraphQL operation.\n   *\n   * @remarks\n   * The `Client.subscription` method is useful to programmatically create and issue a GraphQL subscription operation.\n   * It automatically calls {@link createRequest}, {@link client.createRequestOperation}, and\n   * {@link client.executeRequestOperation} for you, and is a convenience method.\n   *\n   * Hint: This is the recommended way to create subscriptions programmatically when not using the bindings.\n   *\n   * @example\n   * ```ts\n   * import { pipe, subscribe } from 'wonka';\n   *\n   * const getNewsSubscription = gql`\n   *   subscription GetNews {\n   *     breakingNews {\n   *       id\n   *       text\n   *       createdAt\n   *     }\n   *   }\n   * `;\n   *\n   * function subscribeToBreakingNews() {\n   *   const subscription = pipe(\n   *     client.subscription(getNewsSubscription, {}),\n   *     subscribe(result => {\n   *       if (result.data) {\n   *         console.log(result.data.breakingNews.text);\n   *       }\n   *     })\n   *   );\n   *\n   *   return subscription.unsubscribe;\n   * }\n   * ```\n   */\n  subscription<Data = any, Variables extends AnyVariables = AnyVariables>(\n    query: DocumentInput<Data, Variables>,\n    variables: Variables,\n    context?: Partial<OperationContext>\n  ): OperationResultSource<OperationResult<Data, Variables>>;\n\n  /** Creates a `Source` that executes the GraphQL subscription operation for the passed `GraphQLRequest`.\n   *\n   * @param query - a {@link GraphQLRequest}\n   * @param opts - {@link OperationContext} options that'll override and be merged with options from the {@link ClientOptions}.\n   * @returns A {@link PromisifiedSource} issuing the {@link OperationResult | OperationResults} for the GraphQL operation.\n   *\n   * @remarks\n   * The `Client.executeSubscription` method is used to programmatically issue a GraphQL subscription operation.\n   * It automatically calls {@link client.createRequestOperation} and {@link client.executeRequestOperation} for you,\n   * but requires you to create a {@link GraphQLRequest} using {@link createRequest} yourself first.\n   *\n   * @see {@link Client.subscription} for a method that doesn't require calling {@link createRequest} yourself.\n   */\n  executeSubscription<\n    Data = any,\n    Variables extends AnyVariables = AnyVariables,\n  >(\n    query: GraphQLRequest<Data, Variables>,\n    opts?: Partial<OperationContext> | undefined\n  ): OperationResultSource<OperationResult<Data, Variables>>;\n\n  /** Creates a `Source` that executes the GraphQL mutation operation created from the passed parameters.\n   *\n   * @param query - a GraphQL document containing the mutation operation that will be executed.\n   * @param variables - the variables used to execute the operation.\n   * @param opts - {@link OperationContext} options that'll override and be merged with options from the {@link ClientOptions}.\n   * @returns A {@link PromisifiedSource} issuing the {@link OperationResult | OperationResults} for the GraphQL operation.\n   *\n   * @remarks\n   * The `Client.mutation` method is useful to programmatically create and issue a GraphQL mutation operation.\n   * It automatically calls {@link createRequest}, {@link client.createRequestOperation}, and\n   * {@link client.executeRequestOperation} for you, and is a convenience method.\n   *\n   * Since it returns a {@link PromisifiedSource} it may be chained with a `toPromise()` call to only\n   * await a single result in an async function. Since mutations will only typically issue one result,\n   * using this method is recommended.\n   *\n   * Hint: This is the recommended way to create mutations programmatically when not using the bindings,\n   * or when youre trying to get a single, promisified result.\n   *\n   * @example\n   * ```ts\n   * const createPostMutation = gql`\n   *   mutation CreatePost($text: String!) {\n   *     createPost(text: $text) {\n   *       id\n   *       text\n   *     }\n   *   }\n   * `;\n   *\n   * async function createPost(text) {\n   *   const result = await client.mutation(createPostMutation, {\n   *     text,\n   *   }).toPromise();\n   *   if (result.error) {\n   *     throw result.error;\n   *   }\n   *\n   *   return result.data.createPost;\n   * }\n   * ```\n   */\n  mutation<Data = any, Variables extends AnyVariables = AnyVariables>(\n    query: DocumentInput<Data, Variables>,\n    variables: Variables,\n    context?: Partial<OperationContext>\n  ): OperationResultSource<OperationResult<Data, Variables>>;\n\n  /** Creates a `Source` that executes the GraphQL mutation operation for the passed `GraphQLRequest`.\n   *\n   * @param query - a {@link GraphQLRequest}\n   * @param opts - {@link OperationContext} options that'll override and be merged with options from the {@link ClientOptions}.\n   * @returns A {@link PromisifiedSource} issuing the {@link OperationResult | OperationResults} for the GraphQL operation.\n   *\n   * @remarks\n   * The `Client.executeMutation` method is used to programmatically issue a GraphQL mutation operation.\n   * It automatically calls {@link client.createRequestOperation} and {@link client.executeRequestOperation} for you,\n   * but requires you to create a {@link GraphQLRequest} using {@link createRequest} yourself first.\n   *\n   * @see {@link Client.mutation} for a method that doesn't require calling {@link createRequest} yourself.\n   */\n  executeMutation<Data = any, Variables extends AnyVariables = AnyVariables>(\n    query: GraphQLRequest<Data, Variables>,\n    opts?: Partial<OperationContext> | undefined\n  ): OperationResultSource<OperationResult<Data, Variables>>;\n}\n\nexport const Client: new (opts: ClientOptions) => Client = function Client(\n  this: Client | {},\n  opts: ClientOptions\n) {\n  if (process.env.NODE_ENV !== 'production' && !opts.url) {\n    throw new Error('You are creating an urql-client without a url.');\n  }\n\n  let ids = 0;\n\n  const replays = new Map<number, OperationResult>();\n  const active: Map<number, Source<OperationResult>> = new Map();\n  const dispatched = new Set<number>();\n  const queue: Operation[] = [];\n\n  const baseOpts = {\n    url: opts.url,\n    fetchSubscriptions: opts.fetchSubscriptions,\n    fetchOptions: opts.fetchOptions,\n    fetch: opts.fetch,\n    preferGetMethod: opts.preferGetMethod,\n    requestPolicy: opts.requestPolicy || 'cache-first',\n  };\n\n  // This subject forms the input of operations; executeOperation may be\n  // called to dispatch a new operation on the subject\n  const operations = makeSubject<Operation>();\n\n  function nextOperation(operation: Operation) {\n    if (\n      operation.kind === 'mutation' ||\n      operation.kind === 'teardown' ||\n      !dispatched.has(operation.key)\n    ) {\n      if (operation.kind === 'teardown') {\n        dispatched.delete(operation.key);\n      } else if (operation.kind !== 'mutation') {\n        dispatched.add(operation.key);\n      }\n      operations.next(operation);\n    }\n  }\n\n  // We define a queued dispatcher on the subject, which empties the queue when it's\n  // activated to allow `reexecuteOperation` to be trampoline-scheduled\n  let isOperationBatchActive = false;\n  function dispatchOperation(operation?: Operation | void) {\n    if (operation) nextOperation(operation);\n\n    if (!isOperationBatchActive) {\n      isOperationBatchActive = true;\n      while (isOperationBatchActive && (operation = queue.shift()))\n        nextOperation(operation);\n      isOperationBatchActive = false;\n    }\n  }\n\n  /** Defines how result streams are created */\n  const makeResultSource = (operation: Operation) => {\n    let result$ = pipe(\n      results$,\n      // Filter by matching key (or _instance if its set)\n      filter(\n        (res: OperationResult) =>\n          res.operation.kind === operation.kind &&\n          res.operation.key === operation.key &&\n          (!res.operation.context._instance ||\n            res.operation.context._instance === operation.context._instance)\n      ),\n      // End the results stream when an active teardown event is sent\n      takeUntil(\n        pipe(\n          operations.source,\n          filter(op => op.kind === 'teardown' && op.key === operation.key)\n        )\n      )\n    );\n\n    // Mask typename properties if the option for it is turned on\n    if (opts.maskTypename) {\n      result$ = pipe(\n        result$,\n        map(res => ({ ...res, data: maskTypename(res.data, true) }))\n      );\n    }\n\n    if (operation.kind !== 'query') {\n      // Interrupt subscriptions and mutations when they have no more results\n      result$ = pipe(\n        result$,\n        takeWhile(result => !!result.hasNext, true)\n      );\n    } else {\n      result$ = pipe(\n        result$,\n        // Add `stale: true` flag when a new operation is sent for queries\n        switchMap(result => {\n          const value$ = fromValue(result);\n          return result.stale || result.hasNext\n            ? value$\n            : merge([\n                value$,\n                pipe(\n                  operations.source,\n                  filter(op => op.key === operation.key),\n                  take(1),\n                  map(() => {\n                    result.stale = true;\n                    return result;\n                  })\n                ),\n              ]);\n        })\n      );\n    }\n\n    if (operation.kind !== 'mutation') {\n      result$ = pipe(\n        result$,\n        // Store replay result\n        onPush(result => {\n          if (result.stale) {\n            // If the current result has queued up an operation of the same\n            // key, then `stale` refers to it\n            for (const operation of queue) {\n              if (operation.key === result.operation.key) {\n                dispatched.delete(operation.key);\n                break;\n              }\n            }\n          } else if (!result.hasNext) {\n            dispatched.delete(operation.key);\n          }\n          replays.set(operation.key, result);\n        }),\n        // Cleanup active states on end of source\n        onEnd(() => {\n          // Delete the active operation handle\n          dispatched.delete(operation.key);\n          replays.delete(operation.key);\n          active.delete(operation.key);\n          // Interrupt active queue\n          isOperationBatchActive = false;\n          // Delete all queued up operations of the same key on end\n          for (let i = queue.length - 1; i >= 0; i--)\n            if (queue[i].key === operation.key) queue.splice(i, 1);\n          // Dispatch a teardown signal for the stopped operation\n          nextOperation(\n            makeOperation('teardown', operation, operation.context)\n          );\n        })\n      );\n    } else {\n      result$ = pipe(\n        result$,\n        // Send mutation operation on start\n        onStart(() => {\n          nextOperation(operation);\n        })\n      );\n    }\n\n    return share(result$);\n  };\n\n  const instance: Client =\n    this instanceof Client ? this : Object.create(Client.prototype);\n  const client: Client = Object.assign(instance, {\n    suspense: !!opts.suspense,\n    operations$: operations.source,\n\n    reexecuteOperation(operation: Operation) {\n      // Reexecute operation only if any subscribers are still subscribed to the\n      // operation's exchange results\n      if (operation.kind === 'teardown') {\n        dispatchOperation(operation);\n      } else if (operation.kind === 'mutation' || active.has(operation.key)) {\n        let queued = false;\n        for (let i = 0; i < queue.length; i++)\n          queued = queued || queue[i].key === operation.key;\n        if (!queued) dispatched.delete(operation.key);\n        queue.push(operation);\n        Promise.resolve().then(dispatchOperation);\n      }\n    },\n\n    createRequestOperation(kind, request, opts) {\n      if (!opts) opts = {};\n\n      let requestOperationType: string | undefined;\n      if (\n        process.env.NODE_ENV !== 'production' &&\n        kind !== 'teardown' &&\n        (requestOperationType = getOperationType(request.query)) !== kind\n      ) {\n        throw new Error(\n          `Expected operation of type \"${kind}\" but found \"${requestOperationType}\"`\n        );\n      }\n\n      return makeOperation(kind, request, {\n        _instance:\n          kind === 'mutation'\n            ? ((ids = (ids + 1) | 0) as OperationInstance)\n            : undefined,\n        ...baseOpts,\n        ...opts,\n        requestPolicy: opts.requestPolicy || baseOpts.requestPolicy,\n        suspense: opts.suspense || (opts.suspense !== false && client.suspense),\n      });\n    },\n\n    executeRequestOperation(operation) {\n      if (operation.kind === 'mutation') {\n        return withPromise(makeResultSource(operation));\n      }\n\n      return withPromise(\n        lazy<OperationResult>(() => {\n          let source = active.get(operation.key);\n          if (!source) {\n            active.set(operation.key, (source = makeResultSource(operation)));\n          }\n\n          source = pipe(\n            source,\n            onStart(() => {\n              dispatchOperation(operation);\n            })\n          );\n\n          const replay = replays.get(operation.key);\n          if (\n            operation.kind === 'query' &&\n            replay &&\n            (replay.stale || replay.hasNext)\n          ) {\n            return pipe(\n              merge([\n                source,\n                pipe(\n                  fromValue(replay),\n                  filter(replay => replay === replays.get(operation.key))\n                ),\n              ]),\n              switchMap(fromValue)\n            );\n          } else {\n            return source;\n          }\n        })\n      );\n    },\n\n    executeQuery(query, opts) {\n      const operation = client.createRequestOperation('query', query, opts);\n      return client.executeRequestOperation(operation);\n    },\n\n    executeSubscription(query, opts) {\n      const operation = client.createRequestOperation(\n        'subscription',\n        query,\n        opts\n      );\n      return client.executeRequestOperation(operation);\n    },\n\n    executeMutation(query, opts) {\n      const operation = client.createRequestOperation('mutation', query, opts);\n      return client.executeRequestOperation(operation);\n    },\n\n    readQuery(query, variables, context) {\n      let result: OperationResult | null = null;\n\n      pipe(\n        client.query(query, variables, context),\n        subscribe(res => {\n          result = res;\n        })\n      ).unsubscribe();\n\n      return result;\n    },\n\n    query(query, variables, context) {\n      return client.executeQuery(createRequest(query, variables), context);\n    },\n\n    subscription(query, variables, context) {\n      return client.executeSubscription(\n        createRequest(query, variables),\n        context\n      );\n    },\n\n    mutation(query, variables, context) {\n      return client.executeMutation(createRequest(query, variables), context);\n    },\n  } as Client);\n\n  let dispatchDebug: ExchangeInput['dispatchDebug'] = noop;\n  if (process.env.NODE_ENV !== 'production') {\n    const { next, source } = makeSubject<DebugEvent>();\n    client.subscribeToDebugTarget = (onEvent: (e: DebugEvent) => void) =>\n      pipe(source, subscribe(onEvent));\n    dispatchDebug = next as ExchangeInput['dispatchDebug'];\n  }\n\n  // All exchange are composed into a single one and are called using the constructed client\n  // and the fallback exchange stream\n  const composedExchange = composeExchanges(opts.exchanges);\n\n  // All exchanges receive inputs using which they can forward operations to the next exchange\n  // and receive a stream of results in return, access the client, or dispatch debugging events\n  // All operations then run through the Exchange IOs in a pipeline-like fashion\n  const results$ = share(\n    composedExchange({\n      client,\n      dispatchDebug,\n      forward: fallbackExchange({ dispatchDebug }),\n    })(operations.source)\n  );\n\n  // Prevent the `results$` exchange pipeline from being closed by active\n  // cancellations cascading up from components\n  pipe(results$, publish);\n\n  return client;\n} as any;\n\n/** Accepts `ClientOptions` and creates a `Client`.\n * @param opts - A {@link ClientOptions} objects with options for the `Client`.\n * @returns A {@link Client} instantiated with `opts`.\n */\nexport const createClient = Client as any as (opts: ClientOptions) => Client;\n","import type { ASTNode } from './ast';\n\nexport const BREAK = {};\n\nexport function visit<N extends ASTNode>(root: N, visitor: ASTVisitor): N;\nexport function visit<R>(root: ASTNode, visitor: ASTReducer<R>): R;\n\nexport function visit(node: ASTNode, visitor: ASTVisitor | ASTReducer<any>) {\n  const ancestors: Array<ASTNode | ReadonlyArray<ASTNode>> = [];\n  const path: Array<string | number> = [];\n\n  function traverse(\n    node: ASTNode,\n    key?: string | number | undefined,\n    parent?: ASTNode | ReadonlyArray<ASTNode> | undefined\n  ) {\n    let hasEdited = false;\n\n    const enter =\n      (visitor[node.kind] && visitor[node.kind].enter) ||\n      visitor[node.kind] ||\n      (visitor as EnterLeaveVisitor<ASTNode>).enter;\n    const resultEnter = enter && enter.call(visitor, node, key, parent, path, ancestors);\n    if (resultEnter === false) {\n      return node;\n    } else if (resultEnter === null) {\n      return null;\n    } else if (resultEnter === BREAK) {\n      throw BREAK;\n    } else if (resultEnter && typeof resultEnter.kind === 'string') {\n      hasEdited = resultEnter !== node;\n      node = resultEnter;\n    }\n\n    if (parent) ancestors.push(parent);\n\n    let result: any;\n    const copy = { ...node };\n    for (const nodeKey in node) {\n      path.push(nodeKey);\n      let value = node[nodeKey];\n      if (Array.isArray(value)) {\n        const newValue: any[] = [];\n        for (let index = 0; index < value.length; index++) {\n          if (value[index] != null && typeof value[index].kind === 'string') {\n            ancestors.push(node);\n            path.push(index);\n            result = traverse(value[index], index, value);\n            path.pop();\n            ancestors.pop();\n            if (result == null) {\n              hasEdited = true;\n            } else {\n              hasEdited = hasEdited || result !== value[index];\n              newValue.push(result);\n            }\n          }\n        }\n        value = newValue;\n      } else if (value != null && typeof value.kind === 'string') {\n        result = traverse(value, nodeKey, node);\n        if (result !== undefined) {\n          hasEdited = hasEdited || value !== result;\n          value = result;\n        }\n      }\n\n      path.pop();\n      if (hasEdited) copy[nodeKey] = value;\n    }\n\n    if (parent) ancestors.pop();\n    const leave =\n      (visitor[node.kind] && visitor[node.kind].leave) ||\n      (visitor as EnterLeaveVisitor<ASTNode>).leave;\n    const resultLeave = leave && leave.call(visitor, node, key, parent, path, ancestors);\n    if (resultLeave === BREAK) {\n      throw BREAK;\n    } else if (resultLeave !== undefined) {\n      return resultLeave;\n    } else if (resultEnter !== undefined) {\n      return hasEdited ? copy : resultEnter;\n    } else {\n      return hasEdited ? copy : node;\n    }\n  }\n\n  try {\n    const result = traverse(node);\n    return result !== undefined && result !== false ? result : node;\n  } catch (error) {\n    if (error !== BREAK) throw error;\n    return node;\n  }\n}\n\nexport type ASTVisitor = EnterLeaveVisitor<ASTNode> | KindVisitor;\n\ntype KindVisitor = {\n  readonly [NodeT in ASTNode as NodeT['kind']]?: ASTVisitFn<NodeT> | EnterLeaveVisitor<NodeT>;\n};\n\ninterface EnterLeaveVisitor<TVisitedNode extends ASTNode> {\n  readonly enter?: ASTVisitFn<TVisitedNode> | undefined;\n  readonly leave?: ASTVisitFn<TVisitedNode> | undefined;\n}\n\nexport type ASTVisitFn<Node extends ASTNode> = (\n  node: Node,\n  key: string | number | undefined,\n  parent: ASTNode | ReadonlyArray<ASTNode> | undefined,\n  path: ReadonlyArray<string | number>,\n  ancestors: ReadonlyArray<ASTNode | ReadonlyArray<ASTNode>>\n) => any;\n\nexport type ASTReducer<R> = {\n  readonly [NodeT in ASTNode as NodeT['kind']]?: {\n    readonly enter?: ASTVisitFn<NodeT>;\n    readonly leave: ASTReducerFn<NodeT, R>;\n  };\n};\n\ntype ASTReducerFn<TReducedNode extends ASTNode, R> = (\n  node: { [K in keyof TReducedNode]: ReducedField<TReducedNode[K], R> },\n  key: string | number | undefined,\n  parent: ASTNode | ReadonlyArray<ASTNode> | undefined,\n  path: ReadonlyArray<string | number>,\n  ancestors: ReadonlyArray<ASTNode | ReadonlyArray<ASTNode>>\n) => R;\n\ntype ReducedField<T, R> = T extends null | undefined\n  ? T\n  : T extends ReadonlyArray<any>\n    ? ReadonlyArray<R>\n    : R;\n","import type {\n  ASTNode,\n  NameNode,\n  DocumentNode,\n  VariableNode,\n  SelectionSetNode,\n  FieldNode,\n  ArgumentNode,\n  FragmentSpreadNode,\n  InlineFragmentNode,\n  VariableDefinitionNode,\n  OperationDefinitionNode,\n  FragmentDefinitionNode,\n  IntValueNode,\n  FloatValueNode,\n  StringValueNode,\n  BooleanValueNode,\n  NullValueNode,\n  EnumValueNode,\n  ListValueNode,\n  ObjectValueNode,\n  ObjectFieldNode,\n  DirectiveNode,\n  NamedTypeNode,\n  ListTypeNode,\n  NonNullTypeNode,\n} from './ast';\n\nfunction mapJoin<T>(value: readonly T[], joiner: string, mapper: (value: T) => string): string {\n  let out = '';\n  for (let index = 0; index < value.length; index++) {\n    if (index) out += joiner;\n    out += mapper(value[index]);\n  }\n  return out;\n}\n\nfunction printString(string: string) {\n  return JSON.stringify(string);\n}\n\nfunction printBlockString(string: string) {\n  return '\"\"\"\\n' + string.replace(/\"\"\"/g, '\\\\\"\"\"') + '\\n\"\"\"';\n}\n\nconst MAX_LINE_LENGTH = 80;\n\nlet LF = '\\n';\n\nconst nodes = {\n  OperationDefinition(node: OperationDefinitionNode): string {\n    let out: string = node.operation;\n    if (node.name) out += ' ' + node.name.value;\n    if (node.variableDefinitions && node.variableDefinitions.length) {\n      if (!node.name) out += ' ';\n      out += '(' + mapJoin(node.variableDefinitions, ', ', nodes.VariableDefinition) + ')';\n    }\n    if (node.directives && node.directives.length)\n      out += ' ' + mapJoin(node.directives, ' ', nodes.Directive);\n    return out !== 'query'\n      ? out + ' ' + nodes.SelectionSet(node.selectionSet)\n      : nodes.SelectionSet(node.selectionSet);\n  },\n  VariableDefinition(node: VariableDefinitionNode): string {\n    let out = nodes.Variable!(node.variable) + ': ' + _print(node.type);\n    if (node.defaultValue) out += ' = ' + _print(node.defaultValue);\n    if (node.directives && node.directives.length)\n      out += ' ' + mapJoin(node.directives, ' ', nodes.Directive);\n    return out;\n  },\n  Field(node: FieldNode): string {\n    let out = node.alias ? node.alias.value + ': ' + node.name.value : node.name.value;\n    if (node.arguments && node.arguments.length) {\n      const args = mapJoin(node.arguments, ', ', nodes.Argument);\n      if (out.length + args.length + 2 > MAX_LINE_LENGTH) {\n        out +=\n          '(' +\n          (LF += '  ') +\n          mapJoin(node.arguments, LF, nodes.Argument) +\n          (LF = LF.slice(0, -2)) +\n          ')';\n      } else {\n        out += '(' + args + ')';\n      }\n    }\n    if (node.directives && node.directives.length)\n      out += ' ' + mapJoin(node.directives, ' ', nodes.Directive);\n    if (node.selectionSet) out += ' ' + nodes.SelectionSet(node.selectionSet);\n    return out;\n  },\n  StringValue(node: StringValueNode): string {\n    if (node.block) {\n      return printBlockString(node.value).replace(/\\n/g, LF);\n    } else {\n      return printString(node.value);\n    }\n  },\n  BooleanValue(node: BooleanValueNode): string {\n    return '' + node.value;\n  },\n  NullValue(_node: NullValueNode): string {\n    return 'null';\n  },\n  IntValue(node: IntValueNode): string {\n    return node.value;\n  },\n  FloatValue(node: FloatValueNode): string {\n    return node.value;\n  },\n  EnumValue(node: EnumValueNode): string {\n    return node.value;\n  },\n  Name(node: NameNode): string {\n    return node.value;\n  },\n  Variable(node: VariableNode): string {\n    return '$' + node.name.value;\n  },\n  ListValue(node: ListValueNode): string {\n    return '[' + mapJoin(node.values, ', ', _print) + ']';\n  },\n  ObjectValue(node: ObjectValueNode): string {\n    return '{' + mapJoin(node.fields, ', ', nodes.ObjectField) + '}';\n  },\n  ObjectField(node: ObjectFieldNode): string {\n    return node.name.value + ': ' + _print(node.value);\n  },\n  Document(node: DocumentNode): string {\n    if (!node.definitions || !node.definitions.length) return '';\n    return mapJoin(node.definitions, '\\n\\n', _print);\n  },\n  SelectionSet(node: SelectionSetNode): string {\n    return '{' + (LF += '  ') + mapJoin(node.selections, LF, _print) + (LF = LF.slice(0, -2)) + '}';\n  },\n  Argument(node: ArgumentNode): string {\n    return node.name.value + ': ' + _print(node.value);\n  },\n  FragmentSpread(node: FragmentSpreadNode): string {\n    let out = '...' + node.name.value;\n    if (node.directives && node.directives.length)\n      out += ' ' + mapJoin(node.directives, ' ', nodes.Directive);\n    return out;\n  },\n  InlineFragment(node: InlineFragmentNode): string {\n    let out = '...';\n    if (node.typeCondition) out += ' on ' + node.typeCondition.name.value;\n    if (node.directives && node.directives.length)\n      out += ' ' + mapJoin(node.directives, ' ', nodes.Directive);\n    out += ' ' + nodes.SelectionSet(node.selectionSet);\n    return out;\n  },\n  FragmentDefinition(node: FragmentDefinitionNode): string {\n    let out = 'fragment ' + node.name.value;\n    out += ' on ' + node.typeCondition.name.value;\n    if (node.directives && node.directives.length)\n      out += ' ' + mapJoin(node.directives, ' ', nodes.Directive);\n    return out + ' ' + nodes.SelectionSet(node.selectionSet);\n  },\n  Directive(node: DirectiveNode): string {\n    let out = '@' + node.name.value;\n    if (node.arguments && node.arguments.length)\n      out += '(' + mapJoin(node.arguments, ', ', nodes.Argument) + ')';\n    return out;\n  },\n  NamedType(node: NamedTypeNode): string {\n    return node.name.value;\n  },\n  ListType(node: ListTypeNode): string {\n    return '[' + _print(node.type) + ']';\n  },\n  NonNullType(node: NonNullTypeNode): string {\n    return _print(node.type) + '!';\n  },\n} as const;\n\nconst _print = (node: ASTNode): string => nodes[node.kind](node);\n\nfunction print(node: ASTNode): string {\n  LF = '\\n';\n  return nodes[node.kind] ? nodes[node.kind](node) : '';\n}\n\nexport { print, printString, printBlockString };\n","import type { TypeNode, ValueNode } from './ast';\nimport type { Maybe } from './types';\n\nexport function valueFromASTUntyped(\n  node: ValueNode,\n  variables?: Maybe<Record<string, any>>\n): unknown {\n  switch (node.kind) {\n    case 'NullValue':\n      return null;\n    case 'IntValue':\n      return parseInt(node.value, 10);\n    case 'FloatValue':\n      return parseFloat(node.value);\n    case 'StringValue':\n    case 'EnumValue':\n    case 'BooleanValue':\n      return node.value;\n    case 'ListValue': {\n      const values: unknown[] = [];\n      for (const value of node.values) values.push(valueFromASTUntyped(value, variables));\n      return values;\n    }\n    case 'ObjectValue': {\n      const obj = Object.create(null);\n      for (const field of node.fields)\n        obj[field.name.value] = valueFromASTUntyped(field.value, variables);\n      return obj;\n    }\n    case 'Variable':\n      return variables && variables[node.name.value];\n  }\n}\n\nexport function valueFromTypeNode(\n  node: ValueNode,\n  type: TypeNode,\n  variables?: Maybe<Record<string, any>>\n): unknown {\n  if (node.kind === 'Variable') {\n    const variableName = node.name.value;\n    return variables ? valueFromTypeNode(variables[variableName], type, variables) : undefined;\n  } else if (type.kind === 'NonNullType') {\n    return node.kind !== 'NullValue' ? valueFromTypeNode(node, type, variables) : undefined;\n  } else if (node.kind === 'NullValue') {\n    return null;\n  } else if (type.kind === 'ListType') {\n    if (node.kind === 'ListValue') {\n      const values: unknown[] = [];\n      for (const value of node.values) {\n        const coerced = valueFromTypeNode(value, type.type, variables);\n        if (coerced === undefined) {\n          return undefined;\n        } else {\n          values.push(coerced);\n        }\n      }\n      return values;\n    }\n  } else if (type.kind === 'NamedType') {\n    switch (type.name.value) {\n      case 'Int':\n      case 'Float':\n      case 'String':\n      case 'Bool':\n        return type.name.value + 'Value' === node.kind\n          ? valueFromASTUntyped(node, variables)\n          : undefined;\n      default:\n        return valueFromASTUntyped(node, variables);\n    }\n  }\n}\n"],"names":["NAME","DOCUMENT","VARIABLE_DEFINITION","error","message","extensions","name","FRAGMENT_SPREAD","GraphQLError","collectTypes","obj","types","nodes","source","positions","path","Array","isArray","FRAGMENT_DEFINITION","item","OBJ","VARIABLE","Provider","Context","key","input","NULL","graphQLErrors","map","rehydrateGraphQlError","generateErrorMessage","networkErr","graphQlErrs","useClient","useContext","process","err","formatNode","node","definitions","QUERY","fetching","newDefinition","definition","this","undefined","originalError","super","normalizedGraphQLErrors","networkError","areOperationsEqual","a","b","directives","length","toString","_directives","prevState","result","newState","directive","value","push","data","phash","x","i","l","isShallowDifferent","charCodeAt","h","_extensions","selections","originalExtensions","kind","seen","has","Kind","OPERATION_DEFINITION","selectionSet","selection","JSON","hasTypename","stringify","FIELD","alias","newSelection","toJSON","out","Symbol","_generated","toStringTag","NoopConstructor","FileConstructor","BlobConstructor","deferDispatch","setState","keys","Object","then","sort","constructor","getPrototypeOf","prototype","cache","get","Math","random","slice","set","useMutation","query","idx","isMounted","React","useRef","client","state","advance","pattern","initialState","executeMutation","variables","context","lastIndex","formatDocument","keyDocument","formattedDocs","toPromise","take","hasNext","filter","onPush","leadingRe","current","__key","blockString","defineProperty","delete","lines","split","stale","firstNonEmptyLine","extract","lastNonEmptyLine","operation","maskTypename","isRoot","createRequest","commonIndent","d","acc","useRequest","__typename","stringifyVariables","prev","replace","clear","useMemo","request","char","File","Blob","GRAPHQL_STRING_RE","withPromise","_source$","getCacheForClient","source$","sink","REPLACE_CHAR_RE","_react","nameRe","onResolve","onReject","subscribe","Map","onResult","replaceOutsideStrings","str","valueRe","operations$","RegExp","sanitizeDocument","join","trim","ValueGroup","reclaim","makeOperation","stringifyDocument","loc","printed","body","addMetadata","dispose","prints","meta","constant","match","noop","isSuspense","suspense","gql","parts","useQuery","args","ignored","arguments","pause","executeQuery","requestPolicy","fields","operationName","document","env","fragmentNames","hashDocument","_result","parse","resolve","docs","takeWhile","Promise","shouldSkip","exec","mapTypeNames","formattedOperation","_query","_variables","printedVars","Var","deps","useState","cacheExchange","forward","computeNextState","dispatchDebug","getSnapshot","operationCache","hasDepsChanged","isOperationCached","currentResult","resultCache","ops$","cachedOps$","cachedResult","Int","hasResult","type","Float","nextResult","floatPart","subscription","makeResult","BlockString","errors","block","Error","defaultHasNext","String","reexecuteOperation","unsubscribe","complexStringRe","test","updateResult","op","CombinedError","forwardedOps$","tap","response","Enum","opts","typenames","additionalTypenames","Set","collectTypenames","concat","pendingOperations","deepMerge","arguments_","target","useSubscription","handler","_name","typeName","executeSubscription","operations","mergeResultPatch","prevResult","pending","values","hasExtensions","add","payload","incremental","withData","handlerRef","patch","assign","onEnd","prop","NODE_ENV","merge","res","pendingRes","id","subPath","revalidated","ssrExchange","part","params","staleWhileRevalidate","includeExtensions","invalidateQueue","lists","invalidate","startIndex","props","items","children","shift","_loop","Query","ssr","isClient","deserializeResult","Subscription","makeErrorResult","SelectionGroup","makeFetchBody","serialized","getOperationName","documentId","persistedQuery","miss","selectionRe","Spread","makeFetchURL","useGETMethod","preferGetMethod","url","urlParts","splitOutSearchParams","finalUrl","start","indexOf","URLSearchParams","restore","serializeBody","files","extractData","extractFiles","size","FormData","Name","form","_alias","json","restoreData","file","subscriptionExchange","forwardSubscription","enableAllOperations","isSubscriptionOperation","isSubscriptionOperationFn","teardown$","makeFetchOptions","_selectionSet","takeUntil","headers","make","observer","isComplete","extraOptions","sub","fetchOptions","isHeaders","next","forEach","observableish","_arguments","complete","toLowerCase","serializedBody","fragmentDefinition","method","_condition","TextDecoder","boundaryHeaderRe","eventStreamRe","decoder","decode","streamBody","asyncIterator","forward$","chunk","subscriptionResults$","reader","getReader","debugExchange","read","done","cancel","dedupExchange","fetchExchange","async","fetchResults$","mergeMap","chunks","boundary","buffer","boundaryIndex","definitionRe","operationDefinition","_variableDefinitions","fetchOperation","networkMode","makeFetchSource","fetch","contentType","results","parseMultipartMixed","boundaryHeader","isPreamble","preambleIndex","fetchSubscriptions","_defaultValue","composeExchanges","exchanges","reduceRight","exchange","forwarded","vars","share","event","defaultValue","now","variableDefinitions","mapExchange","onOperation","onError","newResult","fromPromise","fromValue","newOperation","fallbackExchange","parseEventStream","string","_options","parseJSON","text","parseMaybeJSON","_x","Client","ids","active","dispatched","queue","baseOpts","parseValue","makeSubject","nextOperation","parseType","status","statusText","BREAK","isOperationBatchActive","dispatchOperation","visitor","AbortController","signal","abortController","traverse","parent","hasEdited","enter","abort","resultEnter","call","ancestors","fromAsyncIterable","makeResultSource","result$","_instance","results$","switchMap","value$","nodeKey","newValue","index","replays","pop","splice","onStart","leave","resultLeave","instance","create","copy","queued","createRequestOperation","mapJoin","joiner","mapper","requestOperationType","getOperationType","printString","printBlockString","executeRequestOperation","lazy","OperationDefinition","replay","VariableDefinition","Directive","SelectionSet","Variable","variable","_print","Field","readQuery","Argument","LF","mutation","onEvent","composedExchange","BooleanValue","_node","IntValue","FloatValue","EnumValue","createClient","ObjectValue","ObjectField","Document","FragmentSpread","InlineFragment","typeCondition","FragmentDefinition","NamedType","ListType","NonNullType","print","valueFromASTUntyped","parseInt","parseFloat","field","valueFromTypeNode","coerced"],"mappings":"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","ignoreList":[1,2,3,4,5,6,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52]}